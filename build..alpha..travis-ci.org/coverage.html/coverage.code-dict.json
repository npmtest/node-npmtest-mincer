{"/home/travis/build/npmtest/node-npmtest-mincer/test.js":"/* istanbul instrument in package npmtest_mincer */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mincer/lib.npmtest_mincer.js":"/* istanbul instrument in package npmtest_mincer */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_mincer = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_mincer = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-mincer/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-mincer && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_mincer */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_mincer\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_mincer.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_mincer.rollup.js'] =\n            local.assetsDict['/assets.npmtest_mincer.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_mincer.__dirname +\n                    '/lib.npmtest_mincer.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/index.js":"'use strict';\n\n\nmodule.exports = require('./lib/mincer');\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer.js":"/**\n *  Mincer\n *\n *  This is a main entry point of the module (an object that you get by calling\n *  `require('mincer')`. You can get access to some of the internal classes\n *  using this object.\n *\n *      var env = new (require('mincer').Environment)(__dirname);\n *\n *  `Mincer` depends on some 3rd-party modules. Most valueble (for understanding\n *  an API) are:\n *\n *  - [Hike](http://nodeca.github.com/hike-js/)\n *  - [Mimoza](http://nodeca.github.com/mimoza/)\n *\n *\n *  ##### EXTENDED BY\n *\n *  - [[Engines]]\n *  - [[Mime]]\n *  - [[Processing]]\n *  - [[Paths]]\n **/\n\n\n'use strict';\n\n\n// Node < 0.8 shims\nvar fs    = require('fs');\nvar path  = require('path');\n\nfs.exists     = fs.exists || path.exists;\nfs.existsSync = fs.existsSync || path.existsSync;\n\npath.sep = path.sep || (path.resolve('.')[0] === '/' ? '/' : '\\\\');\n\n\n// 3rd-party\nvar Mimoza  = require('mimoza');\nvar Hike    = require('hike');\n\n\n// internal\nvar mixin = require('./mincer/common').mixin;\nvar prop  = require('./mincer/common').prop;\nvar Hash  = require('./mincer/common/hash');\n\n\nvar Mincer = module.exports = {};\n\n\n// Engines /////////////////////////////////////////////////////////////////////\n\n\n/**\n *  Mincer.EjsEngine -> EjsEngine\n **/\nMincer.EjsEngine          = require('./mincer/engines/ejs_engine');\n\n\n/**\n *  Mincer.HandlebarsEngine -> HandlebarsEngine\n **/\nMincer.HandlebarsEngine   = require('./mincer/engines/handlebars_engine');\n\n\n/**\n *  Mincer.JadeEngine -> JadeEngine\n **/\nMincer.JadeEngine         = require('./mincer/engines/jade_engine');\n\n/**\n *  Mincer.PugEngine -> PugEngine\n **/\nMincer.PugEngine         = require('./mincer/engines/pug_engine');\n\n/**\n *  Mincer.JstEngine -> JstEngine\n **/\nMincer.JstEngine          = require('./mincer/engines/jst_engine');\n\n\n/**\n *  Mincer.LessEngine -> LessEngine\n **/\nMincer.LessEngine         = require('./mincer/engines/less_engine');\n\n\n/**\n *  Mincer.StylusEngine -> StylusEngine\n **/\nMincer.StylusEngine       = require('./mincer/engines/stylus_engine');\n\n\n/**\n *  Mincer.SassEngine -> SassEngine\n **/\nMincer.SassEngine         = require('./mincer/engines/sass_engine');\n\n\n/**\n *  Mincer.CoffeeEngine -> CoffeeEngine\n **/\nMincer.CoffeeEngine       = require('./mincer/engines/coffee_engine');\n\n\n// Processors //////////////////////////////////////////////////////////////////\n\n\n/**\n *  Mincer.DirectiveProcessor -> DirectiveProcessor\n **/\nMincer.DirectiveProcessor = require('./mincer/processors/directive_processor');\n\n\n/**\n *  Mincer.CharsetNormalizer -> CharsetNormalizer\n **/\nMincer.CharsetNormalizer  = require('./mincer/processors/charset_normalizer');\n\n\n/**\n *  Mincer.SafetyColons -> SafetyColons\n **/\nMincer.SafetyColons       = require('./mincer/processors/safety_colons');\n\n\n/**\n *  Mincer.Autoprefixer -> Autoprefixer\n **/\nMincer.Autoprefixer       = require('./mincer/processors/autoprefixer');\n\n\n/**\n *  Mincer.MacroProcessor -> MacroProcessor\n **/\nMincer.MacroProcessor = require('./mincer/processors/macro_processor');\n\n\n\n// Compressors /////////////////////////////////////////////////////////////////\n\n\n/**\n *  Mincer.CssoCompressor -> CssoCompressor\n **/\nMincer.CssoCompressor     = require('./mincer/compressors/csso_compressor');\n\n\n/**\n *  Mincer.CsswringCompressor -> CsswringCompressor\n **/\nMincer.CsswringCompressor  = require('./mincer/compressors/csswring_compressor');\n\n\n/**\n *  Mincer.UglifyCompressor -> UglifyCompressor\n **/\nMincer.UglifyCompressor   = require('./mincer/compressors/uglify_compressor');\n\n\n// Main exported classes ///////////////////////////////////////////////////////\n\n\n/**\n *  Mincer.Environment -> Environment\n **/\nMincer.Environment        = require('./mincer/environment');\n\n\n/**\n *  Mincer.Manifest -> Manifest\n **/\nMincer.Manifest           = require('./mincer/manifest');\n\n\n/**\n *  Mincer.Template -> Template\n **/\nMincer.Template           = require('./mincer/template');\n\n\n/**\n *  Mincer.Server -> Server\n **/\nMincer.Server             = require('./mincer/server');\n\n\n/**\n *  Mincer.FileStore -> FileStore\n **/\nMincer.FileStore          = require('./mincer/file_store');\n\n\n// Main exported functions /////////////////////////////////////////////////////\n\n\n/** alias of: Server.createServer\n *  Mincer.createServer(environment[, manifest]) -> Function\n **/\nMincer.createServer       = Mincer.Server.createServer;\n\n\n// Main exported properties ////////////////////////////////////////////////////\n\n\n/** read-only\n *  Mincer.VERSION -> String\n **/\nprop(Mincer, 'VERSION', require('./mincer/version'));\n\n\n/** read-only\n *  Mincer.logger -> Logger\n **/\nprop(Mincer, 'logger',  require('./mincer/logger'));\n\n\n// Spicy Sauce :)) /////////////////////////////////////////////////////////////\n\n\n// main internal properties.\n// each new environment clone these properties for initial states,\n// so they can be used to set 'defaults' for all environment instances.\nprop(Mincer, '__trail__',             new Hike(__dirname));\nprop(Mincer, '__engines__',           {});\nprop(Mincer, '__mimeTypes__',         new Mimoza());\nprop(Mincer, '__preProcessors__',     new Hash(function () { return []; }));\nprop(Mincer, '__postProcessors__',    new Hash(function () { return []; }));\nprop(Mincer, '__bundleProcessors__',  new Hash(function () { return []; }));\nprop(Mincer, '__compressors__',       new Hash(function () { return {}; }));\nprop(Mincer, '__configurations__',    {});\n\n\n// mixin helpers\nmixin(Mincer, require('./mincer/helpers/engines'));\nmixin(Mincer, require('./mincer/helpers/mime'));\nmixin(Mincer, require('./mincer/helpers/processing'));\nmixin(Mincer, require('./mincer/helpers/compressing'));\nmixin(Mincer, require('./mincer/helpers/configuring'));\nmixin(Mincer, require('./mincer/helpers/paths'));\n\n\n// register basic mimetypes\nMincer.registerMimeType('text/css',               '.css');\nMincer.registerMimeType('application/javascript', '.js');\n\n\n// register default pre-processors\nMincer.registerPreProcessor('text/css',                 Mincer.DirectiveProcessor);\nMincer.registerPreProcessor('application/javascript',   Mincer.DirectiveProcessor);\n\nMincer.registerPreProcessor('text/css',                 Mincer.MacroProcessor);\nMincer.registerPreProcessor('application/javascript',   Mincer.MacroProcessor);\n\n\n// register default post-processors\nMincer.registerPostProcessor('application/javascript',  Mincer.SafetyColons);\n\n\n// register default bundle-processors\nMincer.registerBundleProcessor('text/css',              Mincer.CharsetNormalizer);\n\n\n// register predefined js compressors\nMincer.registerCompressor('application/javascript', 'uglify',   Mincer.UglifyCompressor);\n\n\n// register predefined css compressors\nMincer.registerCompressor('text/css',               'csso',     Mincer.CssoCompressor);\nMincer.registerCompressor('text/css',               'csswring', Mincer.CsswringCompressor);\n\n\n// Register JS engines\nMincer.registerEngine('.coffee',    Mincer.CoffeeEngine);\nMincer.registerEngine('.litcoffee', Mincer.CoffeeEngine);\n\n\n// Register CSS engines\nMincer.registerEngine('.less',      Mincer.LessEngine);\nMincer.registerEngine('.styl',      Mincer.StylusEngine);\nMincer.registerEngine('.sass',      Mincer.SassEngine);\nMincer.registerEngine('.scss',      Mincer.SassEngine);\n\n\n// JST engines\nMincer.registerEngine('.jst',       Mincer.JstEngine);\n\n\n// Mixed type (JST / processor) engines\nMincer.registerEngine('.ejs',       Mincer.EjsEngine);\nMincer.registerEngine('.hbs',       Mincer.HandlebarsEngine);\nMincer.registerEngine('.jade',      Mincer.JadeEngine);\nMincer.registerEngine('.pug',       Mincer.PugEngine);\n\n\n// Configurations //////////////////////////////////////////////////////////////\n\n\nMincer.registerConfiguration('autoprefixer', {\n  enable: function (self) {\n    self.registerPostProcessor('text/css', Mincer.Autoprefixer);\n  },\n  disable: function (self) {\n    self.unregisterPostProcessor('text/css', Mincer.Autoprefixer);\n  }\n});\n\n\nMincer.registerConfiguration('source_maps', { state: 'disabled' });\n\n\n// Alias for `source_maps`\nMincer.registerConfiguration('source_map', {\n  state:    'disabled',\n  enable:   function (self) { self.enable('source_maps'); },\n  disable:  function (self) { self.disable('source_maps'); }\n});\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/common.js":"'use strict';\n\n\n// stdlib\nvar path = require('path');\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// shorthand for defining getter properties\nmodule.exports.getter = function (obj, name, get) {\n  Object.defineProperty(obj, name, { get: get });\n};\n\n\n// shorthand for defining data descriptors\nmodule.exports.prop = function (obj, name, value, options) {\n  var descriptor = _.assign({}, options, { value: value });\n  Object.defineProperty(obj, name, descriptor);\n};\n\n\n// _.assign implementation that copies descriptors as is\nmodule.exports.mixin = function (baseObj, superObj) {\n  Object.getOwnPropertyNames(superObj).forEach(function (prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(superObj, prop);\n    Object.defineProperty(baseObj, prop, descriptor);\n  });\n};\n\n\n// Dummy alternative to Ruby's Pathname#is_absolute\nmodule.exports.isAbsolute = function (pathname) {\n  if (path.sep === '/') {\n    // unix\n    return pathname[0] === '/';\n  }\n\n  // win\n  return pathname.indexOf(':') >= 0;\n};\n\n\n// Inverse of isAbsolute.\nmodule.exports.isRelative = function (pathname) {\n  return !module.exports.isAbsolute(pathname);\n};\n\n\n// Dummy timer helper\nmodule.exports.timer = function () {\n  return {\n    start: Date.now(),\n    stop: function () {\n      return Date.now() - this.start;\n    }\n  };\n};\n\n\n// use High Resolution timers for Node >= 0.7.6\nif (process.hrtime) {\n  module.exports.timer = function () {\n    return {\n      start: process.hrtime(),\n      stop: function () {\n        var tuple = process.hrtime(this.start);\n        return parseInt(tuple.shift() * 1000 + tuple.pop() / 1000000, 10);\n      }\n    };\n  };\n}\n\n\n// cached empty function\nmodule.exports.noop = function noop() {};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/common/hash.js":"/** internal\n *  class Hash\n *\n *  Thin wraper over Object used internally to keep lists of processors.\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new Hash(defaulter)\n *  - defaulter (Function): default value generator\n **/\nfunction Hash(defaulter) {\n  this.data       = {};\n  this.defaulter  = defaulter;\n}\n\n\n/**\n *  Hash#get(key) -> Mixed\n *  - key (String):\n *\n *  Returns value associated with given key:\n *\n *     processors.get('text/css').push(DirectiveProcessor);\n *\n *  Associates key with value generated by `defaulter` if it does not exists\n *  yet.\n **/\nHash.prototype.get = function (key) {\n  if (!this.data[key]) {\n    this.data[key] = this.defaulter(key);\n  }\n\n  return this.data[key];\n};\n\n\n/**\n *  Hash#set(key, val) -> Void\n *  - key (String):\n *  - val (Mixed):\n *\n *  Set value for a key:\n *\n *     old_val = processors.get('text/css');\n *     new_val = _.without(old_val, MyMegaProcessor);\n *     processors.set('text/css', new_val);\n *\n *  Used to reset value of a key.\n **/\nHash.prototype.set = function (key, val) {\n  this.data[key] = val || this.defaulter(key);\n};\n\n\n/**\n *  Hash#clone() -> Hash\n *\n *  Makes a copy of a Hash.\n *\n *     processors.get('text/css').length;  // => 1\n *\n *     processors_copy = processors.clone();\n *     processors_copy.get('text/css').push(MyMegaProcessor);\n *\n *     processors.get('text/css').length;      // => 1\n *     processors_copy.get('text/css').length; // => 2\n *\n *  Used upon Environment init - clone globally registered processors\n **/\nHash.prototype.clone = function () {\n  var clone = new Hash(this.defaulter);\n\n  Object.keys(this.data).forEach(function (key) {\n    clone.set(key, _.clone(this.data[key]));\n  }, this);\n\n  return clone;\n};\n\n\nmodule.exports = Hash;\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/engines/ejs_engine.js":"/**\n *  class EjsEngine\n *\n *  Engine for the EJS compiler. You will need `ejs` Node module installed\n *  in order to use [[Mincer]] with `*.ejs` files:\n *\n *      npm install ejs\n *\n *  This is a mixed-type engine that can be used as a 'backend' of [[JstEngine]]\n *  as well as standalone 'middleware' processor in a pipeline.\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar ejs; // initialized later\n\n\n// internal\nvar Template = require('../template');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar EjsEngine = module.exports = function EjsEngine() {\n  Template.apply(this, arguments);\n  ejs = ejs || Template.libs.ejs || require('ejs');\n};\n\n\nrequire('util').inherits(EjsEngine, Template);\n\n\n// Render data\nEjsEngine.prototype.evaluate = function (context, locals) {\n  if (this.nextProcessor && this.nextProcessor.name === 'JstEngine') {\n    this.data = ejs.compile(this.data, {\n      filename: context.logicalPath,\n      client:   true\n    }).toString();\n    return;\n  }\n\n  if (ejs.VERSION) { // ejs 2.x.x\n    this.data = ejs.render(this.data, locals, {\n      filename: context.pathname,\n      context:  context\n    });\n  } else { // ejs 1.x.x\n    this.data = ejs.render(this.data, {\n      filename: context.pathname,\n      scope:    context,\n      locals:   locals\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/template.js":"/**\n *  class Template\n *\n *  Template provides a base class for engines and processors. Think of it as of\n *  Ruby's `Tilt::Template` class, that provides unified interface for template\n *  renderers.\n *\n *\n *  ##### Example\n *\n *      // Create subclass\n *      function MyProcessor() { Template.apply(this, arguments); }\n *      require('util').inherits(MyProcessor, Template);\n *\n *      // Define evaluate method\n *      MyProcessor.prototype.evaluate = function (context, locals) {\n *        var data = this.data.toLowerCase();\n *        return data;\n *      };\n **/\n\n\n'use strict';\n\n\n// internal\nvar prop = require('./common').prop;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new Template(file[, reader])\n *  - file (String)\n *  - data (String)\n *\n *  Creates new instance of template and fills it with some base properties.\n **/\nvar Template = module.exports = function Template(file, data, map, nextProcessor) {\n  /** internal\n   *  Template#data -> String\n   *\n   *  A source string to be compiled.\n   *\n   *  ##### See Also\n   *\n   *  - [[Template#evaluate]]\n   **/\n  prop(this, 'data', data, { writable: true });\n  prop(this, 'map',  map,  { writable: true });\n  prop(this, 'file', file);\n  prop(this, 'nextProcessor', nextProcessor);\n};\n\n\n/**\n *  Template#evaluate(context, locals) -> data\n *  - context (Context)\n *  - locals (Object)\n *\n *  Real renderer function.\n *\n *  You _MUST_ redefine this method in your template. By default this method is\n *  throws an Error that it's not implemented.\n *\n *\n *  ##### Example\n *\n *      MyProcessor.prototype.evaluate = function (context, locals) {\n *        var data = this.data.replace(this.secret, '***TOP-SECRET***');\n *        return data;\n *      };\n **/\nTemplate.prototype.evaluate = function (/*context, locals*/) {\n  throw new Error((this.constructor.name || '') +\n                  '#evaluate() is not implemented.');\n};\n\n\n/**\n *  Template.libs -> Object\n *\n *  Third-party libs.\n *\n *  ##### Example\n *\n *      Mincer.Template.libs[\"ejs\"] = require(\"ejs\");\n **/\nTemplate.libs = {};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/engines/handlebars_engine.js":"/**\n *  class HandlebarsEngine\n *\n *  Engine for the Handlebars template language. You will need `handlebars` Node\n *  module installed in order to use [[Mincer]] with `*.hbs` files:\n *\n *     npm install handlebars\n *\n *  This is a mixed-type engine that can be used as a 'backend' of [[JstEngine]]\n *  as well as standalone 'middleware' processor in a pipeline.\n *\n *  **NOTICE** Generated functions require you to have `handlebars` client\n *  runtime to be required:\n *\n *  ``` javascript\n *  //= require handlebars.runtime\n *  //= require templates/hello\n *  ```\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _ = require('lodash');\nvar Handlebars; // initialized later\n\n\n// internal\nvar Template = require('../template');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar HandlebarsEngine = module.exports = function HandlebarsEngine() {\n  Template.apply(this, arguments);\n  Handlebars = Handlebars || Template.libs.handlebars || require('handlebars');\n};\n\n\nrequire('util').inherits(HandlebarsEngine, Template);\n\n\n// Render data\nHandlebarsEngine.prototype.evaluate = function (context, locals) {\n  var data = this.data;\n\n  if (this.nextProcessor && this.nextProcessor.name === 'JstEngine') {\n    data = Handlebars.precompile(data, _.clone(locals));\n    this.data = 'Handlebars.template(' + data + ')';\n    return;\n  }\n\n  this.data = Handlebars.render(data, _.clone(locals));\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/engines/jade_engine.js":"/**\n *  class JadeEngine\n *\n *  Engine for the Jade template language. You will need `jade` Node modules\n *  installed in order to use [[Mincer]] with `*.jade` files:\n *\n *     npm install jade\n *\n *  This is a mixed-type engine that can be used as a 'backend' of [[JstEngine]]\n *  as well as standalone 'middleware' processor in a pipeline.\n *\n *  **NOTICE** Generated functions require you to have `jade` client runtime to\n *  be required:\n *\n *  ``` javascript\n *  //= require jade-runtime\n *  //= require templates/hello\n *  ```\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _ = require('lodash');\nvar Jade;   // initialized later\n\n\n// internal\nvar Template = require('../template');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar JadeEngine = module.exports = function JadeEngine() {\n  Template.apply(this, arguments);\n  Jade = Jade || Template.libs.jade || require('jade');\n};\n\n\nrequire('util').inherits(JadeEngine, Template);\n\n\n// Internal (private) options storage\nvar options = {};\n\n\n/**\n *  JadeEngine.configure(opts) -> Void\n *  - opts (Object):\n *\n *  Allows to set Jade compilation opts.\n *  See Jade compilation opts for details.\n *\n *  Default: `{}`.\n *\n *\n *  ##### Example\n *\n *      JadeEngine.configure({self: true});\n **/\nJadeEngine.configure = function (opts) {\n  options = _.clone(opts);\n};\n\n\n// Render data\nJadeEngine.prototype.evaluate = function (context, locals) {\n  if (this.nextProcessor && this.nextProcessor.name === 'JstEngine') {\n    // Use `compileClient` for Jade v1.0.0+, and `compile` for older versions\n    var compile = Jade.compileClient || Jade.compile;\n\n    this.data = compile(this.data, _.assign({}, options, {\n      client:   true, // needed only for Jade < v1.0.0\n      filename: context.pathname\n    })).toString();\n    return;\n  }\n\n  this.data = Jade.render(this.data, _.assign({}, options, locals, {\n    filename: context.pathname\n  }));\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/engines/pug_engine.js":"/**\n *  class PugEngine\n *\n *  Engine for the Pug template language. You will need `pug` Node modules\n *  installed in order to use [[Mincer]] with `*.pug` files:\n *\n *     npm install pug\n *\n *  This is a mixed-type engine that can be used as a 'backend' of [[JstEngine]]\n *  as well as standalone 'middleware' processor in a pipeline.\n *\n *  **NOTICE** Generated functions require you to have `pug` client runtime to\n *  be required:\n *\n *  ``` javascript\n *  //= require pug-runtime\n *  //= require templates/hello\n *  ```\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _ = require('lodash');\nvar Pug;   // initialized later\n\n\n// internal\nvar Template = require('../template');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar PugEngine = module.exports = function PugEngine() {\n  Template.apply(this, arguments);\n  Pug = Pug || Template.libs.pug || require('pug');\n};\n\n\nrequire('util').inherits(PugEngine, Template);\n\n\n// Internal (private) options storage\nvar options = {};\n\n\n/**\n *  PugEngine.configure(opts) -> Void\n *  - opts (Object):\n *\n *  Allows to set Pug compilation opts.\n *  See Pug compilation opts for details.\n *\n *  Default: `{}`.\n *\n *\n *  ##### Example\n *\n *      PugEngine.configure({self: true});\n **/\nPugEngine.configure = function (opts) {\n  options = _.clone(opts);\n};\n\n\n// Render data\nPugEngine.prototype.evaluate = function (context, locals) {\n  if (this.nextProcessor && this.nextProcessor.name === 'JstEngine') {\n    this.data = Pug.compile(this.data, _.assign({}, options, {\n      filename: context.pathname\n    })).toString();\n    return;\n  }\n\n  this.data = Pug.render(this.data, _.assign({}, options, locals, {\n    filename: context.pathname\n  }));\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/engines/jst_engine.js":"/**\n *  class JstEngine\n *\n *  Engine for the JST files. This is a core wrapper, that wraps function\n *  prepared by view renderers like Haml Coffee.\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// internal\nvar Template  = require('../template');\nvar prop      = require('../common').prop;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar JstEngine = module.exports = function JstEngine() {\n  Template.apply(this, arguments);\n};\n\n\nrequire('util').inherits(JstEngine, Template);\n\n\n// Internal (private) namespace storage\nvar namespace = 'this.JST';\n\n\n/**\n *  JstEngine.configure(ns) -> Void\n *  - ns (String):\n *\n *  Allows to set JST global scope variable name.\n *\n *  Default: `'this.JST'`.\n *\n *\n *  ##### Example\n *\n *      JstEngine.configure('this.tpl');\n **/\nJstEngine.configure = function (ns) {\n  namespace = String(ns);\n};\n\n\n// Render data\nJstEngine.prototype.evaluate = function (context/*, locals*/) {\n  this.data = '(function () { ' +\n    namespace + ' || (' + namespace + ' = {}); ' +\n    namespace + '[' + JSON.stringify(context.logicalPath) + '] = ' +\n    this.data.replace(/$(.)/mg, '$1  ').trimLeft().trimRight() +\n    ' }).call(this);';\n};\n\n\n// Expose default MimeType of an engine\nprop(JstEngine, 'defaultMimeType', 'application/javascript');\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/engines/less_engine.js":"/**\n *  class LessEngine\n *\n *  Engine for the Less compiler. You will need `less` Node module installed\n *  in order to use [[Mincer]] with `*.less` files:\n *\n *      npm install less\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar path = require('path');\n\n// 3rd-party\nvar _ = require('lodash');\nvar less; // initialized later\n\n\n// internal\nvar Template  = require('../template');\nvar prop      = require('../common').prop;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar LessEngine = module.exports = function LessEngine() {\n  Template.apply(this, arguments);\n  less = less || Template.libs.less || require('less');\n};\n\n\nrequire('util').inherits(LessEngine, Template);\n\n\n// helper to generate human-friendly errors.\n// adapted version from original bin/less\nfunction lessError(ctx /*, options*/) {\n  var message = '';\n  var extract = ctx.extract;\n  var error   = [];\n\n  if (ctx.stack || !ctx.hasOwnProperty('index')) { return ctx; }\n\n  if (typeof (extract[0]) === 'string') {\n    error.push((ctx.line - 1) + ' ' + extract[0]);\n  }\n\n  if (extract[1]) {\n    error.push(ctx.line + ' ' +\n               extract[1].slice(0, ctx.column) +\n               extract[1][ctx.column] +\n               extract[1].slice(ctx.column + 1));\n  }\n\n  if (typeof (extract[2]) === 'string') {\n    error.push((ctx.line + 1) + ' ' + extract[2]);\n  }\n\n  error   = error.join('\\n');\n  message = ctx.type + 'Error: ' + ctx.message;\n\n  if (ctx.filename) {\n    message += ' in ' + ctx.filename + ':' + ctx.line + ':' + ctx.column;\n  }\n\n  return new Error(message + '\\n---\\n' + error);\n}\n\n\n// Render data\nLessEngine.prototype.evaluate = function (context, locals) {\n  var error  = null,\n      self   = this,\n      withSourcemap = context.environment.isEnabled('source_maps');\n\n  _.forEach(locals, function (localFunc, localName) {\n    function func() {\n      var extractedLessArguments = _.map(arguments, 'value');\n\n      return new less.tree.Anonymous(localFunc.apply(null, extractedLessArguments));\n    }\n    if (less.version[0] < 2) {\n      less.tree.functions[localName] = func;\n    } else {\n      less.functions.functionRegistry.add(localName, func);\n    }\n  });\n\n\n  //\n  // Legacy (< 2.x) API support\n  //\n\n  if (less.version[0] < 2) {\n    var parser = new (less.Parser)({\n      paths:          [ path.dirname(this.file) ].concat(context.environment.paths),\n      optimization:   1,\n      filename:       this.file,\n      syncImport:     true,\n      strictImports:  false\n    });\n\n    parser.parse(self.data, function (err, tree) {\n      if (err) {\n        error = lessError(err);\n        return;\n      }\n\n      _.keys(parser.imports.files).forEach(function (file) {\n        context.dependOn(file);\n      });\n\n      try {\n\n        if (!withSourcemap) {\n          self.data = tree.toCSS();\n        } else {\n          self.data = tree.toCSS({\n            sourceMap: true,\n            outputSourceFiles: true,\n            // sourceMapBasepath: context.environment.root,\n            // sourceMapRootpath: '/',\n            writeSourceMap: function (output) {\n              // Manually convert paths to relative, because LESS\n              // can make tose absolute for complex cases.\n              var map = JSON.parse(output);\n              var dir = path.dirname(context.pathname);\n              map.sources.forEach(function (file, idx) {\n                var rel = path.relative(dir, file);\n                if (path.sep === '\\\\') { rel = rel.replace('\\\\', '/'); }\n                map.sources[idx] = rel;\n              });\n\n              self.map = JSON.stringify(map);\n            }\n          });\n        }\n      } catch (e) {\n        error = lessError(e);\n      }\n    });\n\n    if (error) { throw error; }\n\n    return;\n  }\n\n  //\n  // 2.+ API\n  //\n\n  less.render(self.data, {\n    paths: [ path.dirname(this.file) ].concat(context.environment.paths),\n    optimization: 1,\n    filename: this.file,\n    syncImport: true,\n    strictImports: false,\n    sourceMap: !withSourcemap ? false : {\n      outputSourceFiles: true\n    }\n  }, function (err, output) {\n    if (err) {\n      error = lessError(err);\n      return;\n    }\n\n    output.imports.forEach(function (file) {\n      context.dependOn(file);\n    });\n\n    self.data = output.css;\n\n    if (withSourcemap) {\n      var map = JSON.parse(output.map);\n      var dir = path.dirname(context.pathname);\n\n      map.sources.forEach(function (file, idx) {\n        var rel = path.relative(dir, file);\n        if (path.sep === '\\\\') { rel = rel.replace('\\\\', '/'); }\n        map.sources[idx] = rel;\n      });\n\n      self.map = JSON.stringify(map);\n    }\n  });\n\n  if (error) { throw error; }\n\n};\n\n\n// Expose default MimeType of an engine\nprop(LessEngine, 'defaultMimeType', 'text/css');\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/engines/stylus_engine.js":"/**\n *  class StylusEngine\n *\n *  Engine for the Stylus compiler. You will need `stylus` Node module installed\n *  in order to use [[Mincer]] with `*.stylus` files:\n *\n *      npm install stylus\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar path = require('path');\nvar fs   = require('fs');\n\n\n// 3rd-party\nvar _ = require('lodash');\nvar stylus; // initialized later\n\n\n// internal\nvar Template  = require('../template');\nvar prop      = require('../common').prop;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar StylusEngine = module.exports = function StylusEngine() {\n  Template.apply(this, arguments);\n  stylus = stylus || Template.libs.stylus || require('stylus');\n};\n\n\nrequire('util').inherits(StylusEngine, Template);\n\nfunction noop() {}\n\n// Internal (private) configurator storage\nvar configurator = noop;\n\n\n/**\n *  StylusEngine.configure(fn) -> Void\n *  - fn (Function)\n *\n *  Sets `function`, that will be running everytime engine will run renderer.\n *\n *      var nib = require('nib');\n *\n *      Stylus.configure(function (style) {\n *        style.use(nib());\n *      });\n *\n *  Default: `function (_) { 'do nothing'; }`\n **/\nStylusEngine.configure = function (fn) {\n  configurator = fn;\n};\n\n\n// Render data\nStylusEngine.prototype.evaluate = function (context, locals) {\n  var withSourcemap = context.environment.isEnabled('source_maps');\n\n  var style = stylus(this.data, {\n    paths:    [ path.dirname(this.file) ].concat(context.environment.paths),\n    filename: this.file,\n    _imports: [],\n    sourcemap: !withSourcemap ? false : {\n      comment: false\n    }\n  });\n\n  var error  = null,\n      result = null;\n\n  // define helpers from the list of passed locals\n  _.forEach(locals, function (helper, name) {\n    if (typeof helper !== 'function') {\n      // Provide object as a function helper\n      style.define(name, function () {\n        return helper;\n      });\n      return;\n    }\n\n    // Stylus determine how much arguments to pass on helper function's length\n    // So we keep amount of arguments reasonable big...\n    style.define(name, function (/*a, b, c, d, e, f, g, h*/) {\n      /*jshint unused:false*/\n      var o = {};\n\n      [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' ].forEach(function (k, i) {\n        o[k] = (this[i] || {}).val;\n      }, arguments);\n\n      if (!('context' in this)) {\n        this.context = context;\n      }\n\n      return helper.call(this, o.a, o.b, o.c, o.d, o.e, o.f, o.g, o.h);\n    });\n  });\n\n  // run registered configurator\n  configurator(style);\n\n  style.render(function (err, css) {\n    if (err) {\n      error = err;\n      return;\n    }\n\n    // add Stylus `@import`s as dependencies of current asset\n    _.forEach(style.options._imports, function (imported) {\n      context.dependOn(imported.path);\n    });\n\n    result = css;\n  });\n\n  if (error) {\n    throw error;\n  }\n\n  this.data = result;\n\n  //\n  // Now add sourcemap info if needed & available.\n  //\n\n  if (withSourcemap && style.sourcemap) {\n    var map  = style.sourcemap;\n    var dir  = path.dirname(context.pathname);\n\n    map.sources.forEach(function (file, idx) {\n      var rel = path.relative(dir, file);\n      if (path.sep === '\\\\') { rel = rel.replace('\\\\', '/'); }\n      map.sources[idx] = rel;\n    });\n\n    // Stylus now returns sourcemap without original sources. We should glue\n    // those manually. See https://github.com/stylus/stylus/issues/2036\n    if (!map.sourcesContent) {\n      map.sourcesContent = map.sources.map(function (source) {\n        var res = '';\n\n        try {\n          res =  fs.readFileSync(path.join(dir, source), 'utf8');\n        } catch (__) {}\n\n        return res;\n      });\n    }\n\n    this.map = JSON.stringify(map);\n  }\n};\n\n\n// Expose default MimeType of an engine\nprop(StylusEngine, 'defaultMimeType', 'text/css');\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/engines/sass_engine.js":"/**\n *  class SassEngine\n *\n *  Engine for the SASS/SCSS compiler. You will need `node-sass` Node module installed\n *  in order to use [[Mincer]] with `*.sass` or `*.scss` files:\n *\n *      npm install node-sass\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n// stdlib\nvar path = require('path');\nvar util = require('util');\n\n// 3rd-party\nvar _ = require('lodash');\nvar sass; // initialized later\n\n\n// internal\nvar Template  = require('../template');\nvar prop      = require('../common').prop;\nvar logger    = require('../logger');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar SassEngine = module.exports = function SassEngine() {\n  Template.apply(this, arguments);\n  sass = sass || Template.libs['node-sass'] || require('node-sass');\n\n  // Ensure node sass module has renderSync method\n  if (!sass.renderSync) {\n    throw new Error('node-sass < v0.5 is not supported.');\n  }\n};\n\n\nrequire('util').inherits(SassEngine, Template);\n\n\n// Internal (private) options storage\nvar options = {\n  sourceComments: false,\n  omitSourceMapUrl: true,\n  sourceMapContents: true\n};\n\n/**\n *  SassEngine.configure(opts) -> Void\n *  - opts (Object):\n *\n *  Allows to set Sass compilation opts.\n *\n *  Default: `{}`.\n *\n *\n *  ##### Example\n *\n *      SassEngine.configure({ sourceComments: true });\n **/\nSassEngine.configure = function (opts) {\n  options = _.assign({}, options, opts);\n};\n\n\n// helper to generate human-friendly errors.\n// adapted version from less_engine.js\nfunction sassError(ctx /*, options*/) {\n  if (ctx.line && ctx.message) { // libsass 3.x error object\n    return new Error('Line ' + ctx.line + ': ' + ctx.message);\n  }\n  if (typeof ctx === 'string') { // libsass error string format: path:line: error: message\n    var error = _.zipObject(\n      [ 'path', 'line', 'level', 'message' ],\n      ctx.split(':', 4).map(function (str) { return str.trim(); })\n    );\n    if (error.line && error.level && error.message) {\n      return new Error('Line ' + error.line + ': ' + error.message);\n    }\n  }\n\n  return new Error(ctx);\n}\n\n\n// Render data\nSassEngine.prototype.evaluate = function (context, locals) {\n  var withSourcemap = context.environment.isEnabled('source_maps');\n\n  try {\n    var result = sass.renderSync(_.assign({}, options, {\n      file:           this.file,\n      data:           this.data,\n      importer:       this.sassImporter.bind(this, context),\n      functions:      this.sassFunctions(locals),\n      includePaths:   [ path.dirname(this.file) ].concat(context.environment.paths),\n      indentedSyntax: /^.*\\.sass$/.test(this.file),\n      outFile:        path.basename(this.file).replace(/\\.(sass|scss)$/, ''),\n      sourceMap:      withSourcemap\n    }));\n\n    this.data = String(result.css || result);\n\n    if (withSourcemap) {\n      this.map = this.normalizeSourceMap(context, String(result.map));\n    }\n\n  } catch (err) {\n    var error = sassError(err);\n    throw error;\n  }\n};\n\n\nSassEngine.prototype.normalizeSourceMap = function (context, map) {\n  map = JSON.parse(map);\n\n  var root = context.environment.root;\n  var base = path.dirname(this.file);\n\n  // Make sure all source paths are relative to the processed file!\n  map.sources = map.sources.map(function (source) {\n    return path.relative(base, path.join(root, source));\n  });\n\n  return JSON.stringify(map);\n};\n\n\n// Returns the argument of the @import() call relative to the asset search paths.\nfunction importArgumentRelativeToSearchPaths(importer, importArgument, searchPaths) {\n  var importAbsolutePath = path.resolve(path.dirname(importer), importArgument);\n  var importSearchPath = _.find(searchPaths, function (path) {\n    return importAbsolutePath.indexOf(path) === 0;\n  });\n  if (importSearchPath) {\n    return path.relative(importSearchPath, importAbsolutePath);\n  }\n}\n\n\nfunction isFileNotFound(error) {\n  return error && error.code === 'FileNotFound';\n}\n\n\nfunction tryDepend(context, importPath) {\n  if (importPath) {\n    try {\n      context.dependOn(importPath);\n    } catch (error) {\n      return error;\n    }\n  }\n}\n\n\nSassEngine.prototype.sassImporter = function (context, url, prev) {\n  var importPath = importArgumentRelativeToSearchPaths(prev, url, context.environment.__trail__.paths);\n  // \"If you have a SCSS or Sass file that you want to import but don't want to compile to a CSS file, you can add an\n  // underscore to the beginning of the filename. ... You can then import these files without using the underscore.\"\n  // https://github.com/sass/sass/blob/d26e6f/doc-src/SASS_REFERENCE.md#partials-partials\n  var underscoredImportPath = importPath && path.join(path.dirname(importPath), '_' + path.basename(importPath));\n\n  var firstError = tryDepend(context, importPath);\n  var secondError = isFileNotFound(firstError) && tryDepend(context, underscoredImportPath);\n\n  // While @import()ing assets outside of the search paths should be strongly discouraged, it is valid. Because the\n  // asset is outside of the search path, there's no way to call depend_on() on it, so we shouldn't throw an error.\n  if (isFileNotFound(firstError) && isFileNotFound(secondError)) {\n    logger.warn(util.format('%s will not change when %s changes, because the file could not be found.', prev, url,\n      firstError.message, secondError.message));\n  }\n\n  return {\n    file: url\n  };\n};\n\nfunction isSassType(obj) {\n  for (var type in sass.types) {\n    if (sass.types.hasOwnProperty(type)) {\n      if (obj instanceof sass.types[type]) { return true; }\n    }\n  }\n\n  return false;\n}\n\nSassEngine.prototype.sassFunctions = function (locals) {\n  return _.transform(locals, function (out, fn, key) {\n    if (!_.isFunction(fn)) {\n      return;\n    }\n\n    var functionName = key + '('\n      + _.range(fn.length)\n        .map(function (i) {\n          // sass function params\n          // add default value to support optional param in helper\n          return '$_' + i + ': \"\"';\n        })\n        .join(',')\n      + ')';\n\n    out[functionName] = function () {\n      // drop done() callback\n      var args = _.toArray(arguments).slice(0, fn.length)\n      .map(function ($arg) {\n        return $arg.getValue();\n      });\n\n      var result = fn.apply(null, args);\n\n      switch (typeof result) {\n        case 'string':\n          return new sass.types.String(result);\n        case 'number':\n          return new sass.types.Number(result);\n        case 'boolean':\n          return new sass.types.Boolean(result);\n        case 'object':\n          if (isSassType(result)) { return result; }\n          // otherwise fall through and throw!\n        default:\n          throw new Error('Unsupported value: ' + result);\n      }\n    };\n  });\n};\n\n\n// Expose default MimeType of an engine\nprop(SassEngine, 'defaultMimeType', 'text/css');\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/logger.js":"/**\n *  class Logger\n *\n *  Provides unified logging interface for Mincer.\n *\n *      Logger.use({\n *        log: function (msg) {\n *          // my logging generic logic\n *        },\n *        debug: function (msg) {\n *          // logic for debug logging\n *        }\n *      });\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n// deaf logger's log function that does nothing\nfunction noop() {}\n\n\n// deaf logger used to provide just a \"dumb\" interface\nvar DEAF_LOGGER = {\n  log:    noop,\n  debug:  noop,\n  info:   noop,\n  warn:   noop,\n  error:  noop\n};\n\n\n// active backend\nvar backend = DEAF_LOGGER;\n\n\n// log level to report\nvar levelToReport = 0;\n\n\n/**\n *  Logger.level(int) -> Logger\n *  - int (Integer): A number respresenting which levels to log\n *\n *  Allows to mute lower log levels. Any log level less than the number\n *  specified will be ignored.\n *\n *  ##### Log levels\n *\n *  - `logger.LOG_LEVEL`    : 0\n *  - `logger.DEBUG_LEVEL`  : 1\n *  - `logger.INFO_LEVEL`   : 2\n *  - `logger.WARN_LEVEL`   : 3\n *  - `logger.ERROR_LEVEL`  : 4\n *\n *  ##### Examples\n *\n *      Logger.level(Logger.WARN_LEVEL);\n *\n *      Logger.Level(4);\n **/\nmodule.exports.level = function (ignoreBelow) {\n  levelToReport = parseInt(ignoreBelow, 10) || 0;\n  return this;\n};\n\n\n/**\n *  Logger.use(logger) -> Logger\n *  - logger (Object): An object that respond to some (or all) log levels\n *\n *  Allows to provide you own logging backend (by default all log messages are\n *  going to \"nowhere\").\n *\n *\n *  ##### Log levels\n *\n *  Your `logger` backend should normally respond to following methods:\n *\n *  - `logger.log(level, message)`  : Used by [[Logger.log]]\n *  - `logger.debug(message)`       : Used by [[Logger.debug]]\n *  - `logger.info(message)`        : Used by [[Logger.info]]\n *  - `logger.warn(message)`        : Used by [[Logger.warn]]\n *  - `logger.error(message)`       : Used by [[Logger.error]]\n *\n *\n *  ##### Example\n *\n *      Logger.use(console);\n **/\nmodule.exports.use = function (logger) {\n  backend = logger;\n  return this;\n};\n\n\n/**\n *  Logger.log(level, message) -> Void\n *\n *  Generic logging method. Used as last resort if `backend` logger (provided\n *  to [[Logger.use]]) have no method for requested level.\n **/\n\n\n/**\n *  Logger.debug(message) -> Void\n *\n *  Used for any non-critical information, that might be useful mostly for\n *  development only.\n **/\n\n\n/**\n *  Logger.info(message) -> Void\n *\n *  Used for important messages.\n **/\n\n\n/**\n *  Logger.warn(message) -> Void\n *\n *  Used for very important messages (e.g. notification about ongoing FS changes\n *  etc).\n **/\n\n\n/**\n *  Logger.error(message) -> Void\n *\n *  Used for logging errors.\n **/\n\n\n_.keys(DEAF_LOGGER).forEach(function (level, index) {\n\n  // e.g. Logger.LOG_LEVEL\n  module.exports[level.toUpperCase() + '_LEVEL'] = index;\n\n  // e.g. Logger.log\n  module.exports[level] = function (message) {\n    // ignore if level is less then `levelToReport`\n    if (index < levelToReport) {\n      return;\n    }\n\n    if (_.isFunction(backend[level])) {\n      backend[level](message);\n      return;\n    }\n\n    // fallback to `backend.log`\n    (backend.log || DEAF_LOGGER.log)(level, message);\n  };\n});\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/engines/coffee_engine.js":"/**\n *  class CoffeeEngine\n *\n *  Engine for the CoffeeScript compiler. You will need `coffee-script` Node\n *  module installed in order to use [[Mincer]] with `*.coffee` and\n *  `*.litcoffee` files:\n *\n *      npm install coffee-script\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar extname = require('path').extname;\n\n\n// 3rd-party\nvar _ = require('lodash');\nvar path = require('path');\nvar coffee; // initialized later\n\n\n// internal\nvar Template  = require('../template');\nvar prop      = require('../common').prop;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar CoffeeEngine = module.exports = function CoffeeEngine() {\n  Template.apply(this, arguments);\n  coffee = coffee || Template.libs.coffee || require('coffee-script');\n};\n\n\nrequire('util').inherits(CoffeeEngine, Template);\n\n\n// Internal (private) options storage\nvar options = { bare: true };\n\n\n/**\n *  CoffeeEngine.configure(opts) -> Void\n *  - opts (Object):\n *\n *  Allows to set CoffeeScript compilation options.\n *  Default: `{bare: true}`.\n *\n *  ##### Example\n *\n *      CoffeeScript.configure({bare: true});\n **/\nCoffeeEngine.configure = function (opts) {\n  options = _.clone(opts);\n};\n\n\n// Render data\nCoffeeEngine.prototype.evaluate = function (context/*, locals*/) {\n  var loc, compileOpts, result;\n\n  compileOpts = _.assign({}, options, {\n    literate: extname(this.file) === '.litcoffee'\n  });\n\n  try {\n    // coffescript result change structure, depending on\n    // soursemaps option.\n    if (context.environment.isEnabled('source_maps')) {\n      compileOpts = _.assign(compileOpts, {\n        inline:      true,\n        sourceMap:   true,\n        sourceFiles: [ path.basename(context.pathname) ]\n      });\n\n      result = coffee.compile(this.data, compileOpts);\n      this.data = result.js;\n      this.map = result.v3SourceMap;\n\n    } else {\n      this.data = coffee.compile(this.data, compileOpts);\n    }\n\n  } catch (err) {\n    loc = err.location;\n\n    if (loc) {\n      loc = 'L' + (loc.first_line + 1) + ':' + (loc.first_column + 1);\n      err.message += ' at ' + loc;\n    }\n\n    throw err;\n  }\n};\n\n\n// Expose default MimeType of an engine\nprop(CoffeeEngine, 'defaultMimeType', 'application/javascript');\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/processors/directive_processor.js":"/**\n *  class DirectiveProcessor\n *\n *  The `DirectiveProcessor` is responsible for parsing and evaluating\n *  directive comments in a source file.\n *\n *  A directive comment starts with a comment prefix, followed by an \"=\",\n *  then the directive name, then any arguments.\n *\n *  - **JavaScript one-line comments:**       `//= require \"foo\"\n *  - **CoffeeScript one-line comments:**     `#= require \"baz\"\n *  - **JavaScript and CSS block comments:**  `*= require \"bar\"\n *\n *  This behavior can be disabled with:\n *\n *      environment.unregisterPreProcessor('text/css', DirectiveProcessor);\n *      environment.unregisterPreProcessor('application/javascript', DirectiveProcessor);\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar path = require('path');\n\n\n// 3rd-party\nvar _           = require('lodash');\nvar shellwords  = require('shellwords').split;\n\n\n// internal\nvar Template    = require('../template');\nvar prop        = require('../common').prop;\nvar getter      = require('../common').getter;\nvar isAbsolute  = require('../common').isAbsolute;\nvar isRelative  = require('../common').isRelative;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Returns an Array of lines.\n// Original idea of cross-platform line splitting taken from Sugar.JS:\n// https://github.com/andrewplummer/Sugar/blob/f6d1c2e9/lib/string.js#L323\nfunction get_lines(str) {\n  return String(str || '').match(/^.*$/gm);\n}\n\n// Directives will only be picked up if they are in the header\n// of the source file. C style (/* */), JavaScript (//), and\n// Ruby (#) comments are supported.\n//\n// Directives in comments after the first non-whitespace line\n// of code will not be processed.\nvar HEADER_PATTERN = new RegExp(\n  '^(?:\\\\s*' +\n    '(' +\n      '(?:\\/[*](?:\\\\s*|.+?)*?[*]\\/)' + '|' +\n      '(?:###\\n(?:\\\\s*|.+?)*?\\n###)' + '|' +\n      '(?:\\/\\/.*\\n?)+' + '|' +\n      '(?:#.*\\n?)+' +\n    ')*' +\n  ')*', 'm');\n\n\n// Directives are denoted by a `=` followed by the name, then\n// argument list.\n//\n// A few different styles are allowed:\n//\n//     // =require foo\n//     //= require foo\n//     //= require \"foo\"\n//\nvar DIRECTIVE_PATTERN = new RegExp('^\\\\W*=\\\\s*(\\\\w+.*?)(\\\\*\\\\/)?$');\n\n\n// Real directive processors\nvar DIRECTIVE_HANDLERS = {\n  // The `require` directive functions similar to Ruby's `require`.\n  // It provides a way to declare a dependency on a file in your path\n  // and ensures it's only loaded once before the source file.\n  //\n  // `require` works with files in the environment path:\n  //\n  //     //= require \"foo.js\"\n  //\n  // Extensions are optional. If your source file is \".js\", it\n  // assumes you are requiring another \".js\".\n  //\n  //     //= require \"foo\"\n  //\n  // Relative paths work too. Use a leading `./` to denote a relative\n  // path:\n  //\n  //     //= require \"./bar\"\n  //\n  require: function (self, args) {\n    var pathname = isRelative(args[0]) ? args[0] : ('./' + args[0]);\n\n    self.context.requireAsset(pathname);\n  },\n\n  // `require_self` causes the body of the current file to be\n  // inserted before any subsequent `require` or `include`\n  // directives. Useful in CSS files, where it's common for the\n  // index file to contain global styles that need to be defined\n  // before other dependencies are loaded.\n  //\n  //     /*= require \"reset\"\n  //      *= require_self\n  //      *= require_tree .\n  //      */\n  //\n  require_self: function (self/*, args*/) {\n    if (self.__hasWrittenBody__) {\n      throw new Error('require_self can only be called once per source file');\n    }\n\n    self.context.requireAsset(self.pathname);\n    self.processSource();\n\n    prop(self, '__hasWrittenBody__', true);\n    self.includedPathnames = [];\n  },\n\n\n  // The `include` directive works similar to `require` but\n  // inserts the contents of the dependency even if it already\n  // has been required.\n  //\n  //     //= include \"header\"\n  //\n  include: function (self, args) {\n    var pathname = self.context.resolve(args[0]);\n\n    self.context.dependOnAsset(pathname);\n    self.includedPathnames.push(pathname);\n  },\n\n\n  // `require_directory` requires all the files inside a single\n  // directory. It's similar to `path/*` since it does not follow\n  // nested directories.\n  //\n  //     //= require_directory \"./javascripts\"\n  //\n  require_directory: function (self, args) {\n    var root, pathname = args[0] || '.', stat;\n\n    if (isAbsolute(pathname)) {\n      throw new Error('require_directory argument must be a relative path');\n    }\n\n    root = path.resolve(path.dirname(self.pathname), pathname);\n    stat = self.stat(root);\n\n    if (!stat || !stat.isDirectory()) {\n      throw new Error('require_directory argument must be a directory');\n    }\n\n    self.context.dependOn(root);\n\n    _.forEach(self.entries(root), function (pathname) {\n      pathname = path.join(root, pathname);\n\n      if (self.file === pathname) {\n        return;\n      } else if (self.context.isAssetRequirable(pathname)) {\n        self.context.requireAsset(pathname);\n      }\n    });\n  },\n\n\n  // `require_tree` requires all the nested files in a directory.\n  // Its glob equivalent is `path/**/*`.\n  //\n  //     //= require_tree \"./public\"\n  //\n  require_tree: function (self, args) {\n    var root, pathname = args[0] || '.', stat;\n\n    if (isAbsolute(pathname)) {\n      throw new Error('require_tree argument must be a relative path');\n    }\n\n    root = path.resolve(path.dirname(self.pathname), pathname);\n    stat = self.stat(root);\n\n    if (!stat || !stat.isDirectory()) {\n      throw new Error('require_tree argument must be a directory');\n    }\n\n    self.context.dependOn(root);\n    self.eachEntry(root, function (pathname) {\n      if (self.file === pathname) {\n        return;\n      } else if (self.stat(pathname).isDirectory()) {\n        self.context.dependOn(pathname);\n      } else if (self.context.isAssetRequirable(pathname)) {\n        self.context.requireAsset(pathname);\n      }\n    });\n  },\n\n\n  // Allows you to state a dependency on a file without\n  // including it.\n  //\n  // This is used for caching purposes. Any changes made to\n  // the dependency file will invalidate the cache of the\n  // source file.\n  //\n  // This is useful if you are using ERB and File.read to pull\n  // in contents from another file.\n  //\n  //     //= depend_on \"foo.png\"\n  //\n  depend_on: function (self, args) {\n    self.context.dependOn(args[0]);\n  },\n\n  // Allows you to state a dependency on an asset without including\n  // it.\n  //\n  // This is used for caching purposes. Any changes that would\n  // invalid the asset dependency will invalidate the cache our the\n  // source file.\n  //\n  // Unlike `depend_on`, the path must be a requirable asset.\n  //\n  //     //= depend_on_asset \"bar.js\"\n  //\n  depend_on_asset: function (self, args) {\n    self.context.dependOnAsset(args[0]);\n  },\n\n  // Allows dependency to be excluded from the asset bundle.\n  //\n  // The `path` must be a valid asset and may or may not already\n  // be part of the bundle. Once stubbed, it is blacklisted and\n  // can't be brought back by any other `require`.\n  //\n  //     //= stub \"jquery\"\n  //\n  stub: function (self, args) {\n    self.context.stubAsset(args[0]);\n  }\n};\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar DirectiveProcessor = module.exports = function DirectiveProcessor() {\n  Template.apply(this, arguments);\n};\n\n\nrequire('util').inherits(DirectiveProcessor, Template);\n\n\n// Run processor\nDirectiveProcessor.prototype.evaluate = function (context/*, locals*/) {\n  var self    = this,\n      header  = (HEADER_PATTERN.exec(this.data) || []).shift() || '';\n\n  // drop trailing spaces and line breaks\n  header = header.trimRight();\n\n  prop(this, 'pathname',            this.file);\n  prop(this, 'header',              header);\n  prop(this, 'body',                this.data.substr(header.length) + '\\n');\n  prop(this, 'includedPathnames',   [], { writable: true });\n\n  prop(this, 'context',             context);\n  prop(this, 'result',              '', { writable: true });\n\n  self.processDirectives();\n  self.processSource();\n\n  this.data = self.result;\n};\n\n\n/**\n *  DirectiveProcessor#processDirectives() -> Void\n *\n *  Executes handlers for found directives.\n *\n *  ##### See Also:\n *\n *  - [[DirectiveProcessor#directives]]\n **/\nDirectiveProcessor.prototype.processDirectives = function () {\n  var self = this;\n\n  // Execute handler for each found directive\n  _.forEach(this.directives, function (arr) {\n    self.context.__LINE__ = arr[0];\n    // arr = [\n    //         10,         # 0: LINE\n    //         'require',  # 1: DIRECTIVE\n    //         ['foobar']  # 2: [ARGUMENTS]\n    //       ]\n    DIRECTIVE_HANDLERS[arr[1]](self, arr[2]);\n    self.context.__LINE__ = null;\n  });\n};\n\n\nDirectiveProcessor.prototype.processSource = function () {\n  var self = this;\n\n  // if our own body was not yet appended, and there are header comments,\n  // prepend these coments first.\n  if (!self.__hasWrittenBody__ && self.processedHeader.length > 0) {\n    self.result += self.processedHeader;\n  }\n\n  // process and append body of each path that should be included\n  _.forEach(self.includedPathnames, function (pathname) {\n    self.result += self.context.evaluate(pathname, {});\n  });\n\n  // append own body of source only, if it was not yet written\n  // (with `require_self` directive).\n  if (!self.__hasWrittenBody__) {\n    self.result += self.body;\n  }\n};\n\n\n// Tells whenever given line is directive or not by\n// comparing found directives line indexes with `lineno`\nfunction is_directive(directives, lineno) {\n  return _.some(directives, function (arr) { return arr[0] === lineno; });\n}\n\n\n/**\n *  DirectiveProcessor#processedHeader -> String\n *\n *  Returns the header String with any directives stripped.\n **/\ngetter(DirectiveProcessor.prototype, 'processedHeader', function () {\n  var header;\n\n  if (!this.__processedHeader__) {\n    header = get_lines(this.header).map(function (line, index) {\n      var parts;\n\n      if (is_directive(this.directives, index + 1)) {\n        parts = line.split('=');\n        line  = parts.shift() + '(=)' + parts.join('=');\n      }\n\n      return line;\n    }, this).join('\\n');\n\n    prop(this, '__processedHeader__', header);\n  }\n\n  return this.__processedHeader__;\n});\n\n\n/**\n *  DirectiveProcessor#processedSource -> String\n *\n *  Returns the source String with any directives stripped.\n **/\ngetter(DirectiveProcessor.prototype, 'processedSource', function () {\n  if (!this.__processedSource__) {\n    this.__processedSource__ = this.processedHeader + this.body;\n  }\n\n  return this.__processedSource__;\n});\n\n\n/**\n *  DirectiveProcessor#directives -> Array\n *\n *  Returns an Array of directive structures. Each structure\n *  is an Array with the line number as the first element, the\n *  directive name as the second element, third is an array of\n *  arguments.\n *\n *      [[1, \"require\", [\"foo\"]], [2, \"require\", [\"bar\"]]]\n **/\ngetter(DirectiveProcessor.prototype, 'directives', function () {\n  if (!this.__directives__) {\n    prop(this, '__directives__', []);\n\n    get_lines(this.header).forEach(function (line, index) {\n      var matches = DIRECTIVE_PATTERN.exec(line), name, args;\n\n      if (matches && matches[1]) {\n        args = shellwords(matches[1]);\n        name = args.shift();\n\n        if (_.isFunction(DIRECTIVE_HANDLERS[name])) {\n          this.__directives__.push([ index + 1, name, args ]);\n        }\n      }\n    }, this);\n  }\n\n  return this.__directives__;\n});\n\n\nDirectiveProcessor.prototype.stat = function (pathname) {\n  return this.context.environment.stat(pathname);\n};\n\n\nDirectiveProcessor.prototype.entries = function (pathname) {\n  return this.context.environment.entries(pathname);\n};\n\n\nDirectiveProcessor.prototype.eachEntry = function (path, func) {\n  return this.context.environment.eachEntry(path, func);\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/processors/charset_normalizer.js":"/**\n *  class CharsetNormalizer\n *\n *  Some browsers have issues with stylesheets that contain multiple\n *  `@charset` definitions. The `CharsetNormalizer` processor strips\n *  out multiple `@charset` definitions.\n *\n *  The current implementation is naive. It picks the first `@charset`\n *  it sees and strips the others. This works for most people because\n *  the other definitions are usually `UTF-8`. A more sophisticated\n *  approach would be to re-encode stylesheets with mixed encodings.\n *\n *  This behavior can be disabled with:\n *\n *      environment.unregisterBundleProcessor('text/css', CharsetNormalizer);\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// internal\nvar Template = require('../template');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar CharsetNormalizer = module.exports = function CharsetNormalizer() {\n  Template.apply(this, arguments);\n};\n\n\nrequire('util').inherits(CharsetNormalizer, Template);\n\n\n// Cached version of RegExp used to find and process charset directives\nvar CHARSET_RE = /^@charset \"([^\"]+)\";$/gm;\n\n\n\n// Process data\nCharsetNormalizer.prototype.evaluate = function (/*context, locals*/) {\n  var charset = null;\n\n  this.data = this.data.replace(CHARSET_RE, function (m) {\n    charset = charset || m;\n    return '';\n  });\n\n  if (charset !== null) {\n    this.data = charset + '\\n' + this.data;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/processors/safety_colons.js":"/**\n *  class SafetyColons\n *\n *  For JS developers who are colonfobic, concatenating JS files using\n *  the module pattern usually leads to syntax errors.\n *\n *  The `SafetyColons` processor will insert missing semicolons to the\n *  end of the file.\n *\n *  This behavior can be disabled with:\n *\n *      environment.unregisterPostProcessor('application/javascript', SafetyColons);\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// internal\nvar Template = require('../template');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar SafetyColons = module.exports = function SafetyColons() {\n  Template.apply(this, arguments);\n};\n\n\nrequire('util').inherits(SafetyColons, Template);\n\n\n\n// Process data\nSafetyColons.prototype.evaluate = function (/*context, locals*/) {\n  var data = this.data.trimRight();\n\n  if (data[data.length - 1] !== ';') {\n    data += '\\n;\\n';\n  }\n\n  this.data = data;\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/processors/autoprefixer.js":"/**\n *  class Autoprefixer\n *\n *  Post processor that runs autoprefixer for css. You will need `autoprefixer`\n *  and `postcss` Node modules installed:\n *\n *      npm install autoprefixer\n *      npm install postcss\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _    = require('lodash');\nvar path = require('path');\nvar autoprefixer, postcss; // initialized later\n\n\n// internal\nvar Template = require('../template');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar Autoprefixer = module.exports = function Autoprefixer() {\n  Template.apply(this, arguments);\n  autoprefixer = autoprefixer || Template.libs.autoprefixer || require('autoprefixer');\n  postcss = postcss || Template.libs.postcss || require('postcss');\n};\n\n\nrequire('util').inherits(Autoprefixer, Template);\n\n\n// Internal (private) requirements storage\nvar requirements;\n\n\n/**\n *  Autoprefixer.configure(reqs) -> Void\n *  - reqs (Array|String):\n *\n *  Allows to set Autoprefixer requirements.\n *\n *  Default: `undefined`.\n *\n *\n *  ##### Example\n *\n *      Autoprefixer.configure(['> 1%', 'ie 8']);\n **/\nAutoprefixer.configure = function (reqs) {\n  requirements = _.clone(reqs);\n};\n\n\n// Prefix data\nAutoprefixer.prototype.evaluate = function (context/*, locals*/) {\n  var ap = postcss([ autoprefixer({ browsers: requirements }) ]),\n      result;\n\n  if (!context.environment.isEnabled('source_maps')) {\n    this.data = ap.process(this.data).css;\n    return;\n  }\n\n  // Reset sourceRoot bebore process - we work with relative paths\n  var map = context.createSourceMapObject(this);\n\n  result = ap.process(this.data, {\n    map: {\n      prev:   map,\n      inline: false\n    },\n    from: path.basename(context.pathname),\n    to:   path.basename(context.pathname)\n  });\n\n  this.map  = result.map.toString();\n  this.data = result.css;\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/processors/macro_processor.js":"/**\n *  class MacroProcessor\n *\n *  `MacroProcessor` is simple and effective replacement for EJS, when user\n *  needs just embed constants into file. Macros content is replaced with\n *  evaluated value. You can use all mincer helpers (locals) in expression.\n *\n *  ##### Example of use:\n *\n *  ```javascript\n *  var url = \"'$$ asset_path('/vendor/jquery') $$'\";\n *  var str = '\"$$ function () { var foo = my_super_helpers(5) + 23; return foo; } $$\"';\n *  var str = '$$ JSON.stringify(asset_path(\"/vendor/jquery\")) $$';\n *  ```\n *\n *  MacroProcessor processor is always on, but not assigned to any file\n *  extention. You can enable macros with `configure()` method.\n *\n *  ##### Example of configure:\n *\n *  ```javascript\n *  var mincer = require('mincer');\n *\n *  // Enable for `.js` / `.css` / `.jade`\n *  mincer.Macro.configure(['.js', '.css', '.jade']);\n *\n *  // Enable for `.js` only\n *  mincer.Macro.configure('.js', true);\n *  ```\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\nvar format = require('util').format;\n\n\n// internal\nvar Template = require('../template');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar MacroProcessor = module.exports = function MacroProcessor() {\n  Template.apply(this, arguments);\n};\n\nrequire('util').inherits(MacroProcessor, Template);\n\n\n// Internal (private) config storage\nvar config = {};\nvar DEFAULT_RULES = [ /'\\$\\$([^\\r\\n]+?)\\$\\$'/g, /\"\\$\\$([^\\r\\n]+?)\\$\\$\"/g ];\n\n/**\n *  MacroProcessor.configure(extention, enable) -> Void\n *  - extention (String|Array): extention or array of extentions to process\n *  - enable (Boolean): `false` - disable, `true` or undefined - enable\n *\n *  on / off macroses for specified extentions.\n *\n *\n *  ##### Example\n *\n *  ```javascript\n *  // Enable for `.js` / `.css` / `.jade`\n *  MacroProcessor.configure(['.js', '.css', '.jade']);\n *  MacroProcessor.configure(['.js', '.css', '.jade'], true);\n *\n *  // Enable for `.js` only\n *  MacroProcessor.configure('.js', true);\n *  ```\n **/\nMacroProcessor.configure = function (extention, enable) {\n  extention = Array.isArray(extention) ? extention : [ extention ];\n\n  // normalize extention format ('js' -> '.js')\n  extention = extention.map(function (ext) {\n    return ext[0] === '.' ? ext : '.' + ext;\n  });\n\n  extention.forEach(function (ext) {\n    if (enable === false) {\n      config[ext] = null;\n      return;\n    }\n\n    config[ext] = DEFAULT_RULES;\n  });\n};\n\n\n// cache generated functions, to buid new one only if `locals` change.\nvar evaluatorCache = {};\n\n\n// Replace macros\nMacroProcessor.prototype.evaluate = function (context, locals) {\n  var body = '', ext,\n      key = Object.keys(locals).toString();\n\n  // search nearest extention, that has enabled macros rules\n  ext = context.environment.attributesFor(context.pathname).extensions\n          .reverse()\n          .filter(function (extention) {\n            return !!config[extention];\n          })[0];\n\n  if (!ext) {\n    return;\n  }\n\n  // create evaluator wrapper\n  if (!evaluatorCache.hasOwnProperty(key)) {\n    // build function, that allow macro to access `local` keys by name directly.\n    Object.keys(locals).forEach(function (key) {\n      body += 'var ' + key + ' = __locals.' + key + ';\\n';\n    });\n    body += 'return eval(data);\\n';\n    /*eslint-disable no-new-func*/\n    evaluatorCache[key] = new Function('data', '__locals', body);\n  }\n\n  var result = this.data;\n\n  config[ext].forEach(function (rule) {\n    result = result.replace(rule, function (match, value, offset, orig) {\n      try {\n        return evaluatorCache[key](value, locals);\n      } catch (e) {\n        // Fill error message\n        context.__LINE__ = orig.slice(0, offset).split(/\\r?\\n/).length;\n        throw new Error(format('Failed to evaluate macro `%s` [%s]',\n                        value.trim(), e.message));\n      }\n    });\n  });\n\n  this.data = result;\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/compressors/csso_compressor.js":"/**\n *  class CssoCompressor\n *\n *  Engine for CSS minification. You will need `csso` Node module installed:\n *\n *      npm install csso\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar csso; // initialized later\n\n\n// internal\nvar Template = require('../template');\nvar prop     = require('../common').prop;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar CssoCompressor = module.exports = function CssoCompressor() {\n  Template.apply(this, arguments);\n  csso = csso || Template.libs.csso || require('csso');\n};\n\n\nrequire('util').inherits(CssoCompressor, Template);\n\n\n// Compress data\nCssoCompressor.prototype.evaluate = function (/*context, locals*/) {\n  // CSSO 2.+ renamed .justDoIt() -> .minify()\n  this.data = csso.minify ? csso.minify(this.data) : csso.justDoIt(this.data);\n};\n\n\n// Expose default MimeType of an engine\nprop(CssoCompressor, 'defaultMimeType', 'text/css');\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/compressors/csswring_compressor.js":"/**\n *  class CsswringCompressor\n *\n *  Engine for CSS minification. Less powerful than CSSO, but with sourcemaps\n *  support. You will need `csswring` Node module installed:\n *\n *      npm install csswring\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar path      = require('path');\nvar csswring, postcss; // initialized later\n\n\n// internal\nvar Template = require('../template');\nvar prop     = require('../common').prop;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar CsswringCompressor = module.exports = function CsswringCompressor() {\n  Template.apply(this, arguments);\n  csswring = csswring || Template.libs.csswring || require('csswring');\n  postcss = postcss || Template.libs.postcss || require('postcss');\n};\n\n\nrequire('util').inherits(CsswringCompressor, Template);\n\n\n// Compress data\nCsswringCompressor.prototype.evaluate = function (context/*, locals*/) {\n  var config, result;\n\n  if (!context.environment.isEnabled('source_maps')) {\n    config = {\n      preserveHacks: true,\n      removeAllComments: true\n    };\n    this.data = postcss([ csswring(config) ]).process(this.data, config).css;\n    return;\n  }\n\n  // Reset sourceRoot bebore process - we work with relative paths\n  var map = context.createSourceMapObject(this);\n\n  config = {\n    map: {\n      prev:   map,\n      inline: false\n    },\n    from: path.basename(context.pathname),\n    to:   path.basename(context.pathname),\n    preserveHacks: true,\n    removeAllComments: true\n  };\n\n  result = postcss([ csswring(config) ]).process(this.data, config);\n\n  this.map  = result.map.toString();\n  this.data = result.css;\n};\n\n\n// Expose default MimeType of an engine\nprop(CsswringCompressor, 'defaultMimeType', 'text/css');\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/compressors/uglify_compressor.js":"/**\n *  class UglifyCompressor\n *\n *  Engine for CSS minification. You will need `uglify-js` Node module installed:\n *\n *      npm install uglify-js\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _    = require('lodash');\nvar path = require('path');\nvar UglifyJS; // initialized later\n\n\n// internal\nvar Template = require('../template');\nvar prop     = require('../common').prop;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Class constructor\nvar UglifyCompressor = module.exports = function UglifyCompressor() {\n  Template.apply(this, arguments);\n  UglifyJS = UglifyJS || Template.libs['uglify-js'] || require('uglify-js');\n\n  // Ensure UglifyJS v2 API\n  if (UglifyJS.parser) {\n    throw new Error('UglifyJS v1 not supported, please upgrade library.');\n  }\n};\n\n\nrequire('util').inherits(UglifyCompressor, Template);\n\n\n// Internal (private) options storage\nvar options = {};\n\n\n/**\n *  UglifyCompressor.configure(opts) -> Void\n *  - opts (Object):\n *\n *  Allows to set UglifyJS options.\n *  See UglifyJS minify options for details.\n *\n *  Default: `{}`.\n *\n *\n *  ##### Example\n *\n *      UglifyCompressor.configure({mangle: false});\n **/\nUglifyCompressor.configure = function (opts) {\n  options = _.clone(opts);\n};\n\n\n// Compress data\nUglifyCompressor.prototype.evaluate = function (context/*, locals*/) {\n  var opts = _.merge(options, { fromString: true }),\n      result, origSourceMap, sourceMap;\n\n  if (!context.environment.isEnabled('source_maps')) {\n    this.data = UglifyJS.minify(this.data, opts).code;\n    return;\n  }\n\n  // Built-in 'UglifyJS.minify' miss sources from input sourcemap\n  // (it expect src only from minified files)\n  // We create custom source_map object, and push src files manually\n  origSourceMap = context.createSourceMapObject(this);\n\n  /*eslint-disable new-cap*/\n  sourceMap     = UglifyJS.SourceMap({\n    file: path.basename(context.pathname),\n    orig: origSourceMap\n  });\n\n  origSourceMap.sources.forEach(function (src, idx) {\n    sourceMap.get().setSourceContent(src, origSourceMap.sourcesContent[idx]);\n  });\n\n  _.assign(opts, { output: { source_map: sourceMap } });\n  result = UglifyJS.minify(this.data, opts);\n\n  this.map  = result.map;\n  this.data = result.code;\n};\n\n\n// Expose default MimeType of an engine\nprop(UglifyCompressor, 'defaultMimeType', 'application/javascript');\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/environment.js":"/**\n *  class Environment\n *\n *  The heart of `Mincer`. Stores registered paths, engines, processors, etc.\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Base]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _       = require('lodash');\nvar Hike    = require('hike');\n\n\n// internal\nvar Mincer  = require('../mincer');\nvar Base    = require('./base');\nvar Context = require('./context');\nvar Index   = require('./index');\nvar getter  = require('./common').getter;\nvar prop    = require('./common').prop;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new Environment(root)\n **/\nvar Environment = module.exports = function Environment(root) {\n  Base.call(this);\n\n  // set digestAlgorithm an environment version\n  this.digestAlgorithm  = 'md5';\n  this.version          = '';\n\n  /**\n   *  Environment#ContextClass -> Context\n   *\n   *  Copy of [[Context]] class, that is safe for any mutations.\n   *  Use it to provide your own helpers.\n   *\n   *\n   *  ##### See Also\n   *\n   *  - [[Environment#registerHelper]]\n   **/\n  prop(this, 'ContextClass',          Context.subclass);\n\n  /**\n   *  Environment#sourceRoot -> String\n   *\n   *  `sourceRoot` property for generated source maps.\n   *  Can be used to beatify nesting level in dev tools.\n   *\n   *  Default: '/'.\n   **/\n  prop(this, 'sourceRoot',            '/', { writable: true });\n\n  // define internal properties\n  prop(this, '__trail__',             new Hike(root || '.'));\n  prop(this, '__engines__',           Mincer.getEngines());\n  prop(this, '__mimeTypes__',         Mincer.registeredMimeTypes);\n  prop(this, '__preProcessors__',     Mincer.getPreProcessors());\n  prop(this, '__postProcessors__',    Mincer.getPostProcessors());\n  prop(this, '__bundleProcessors__',  Mincer.getBundleProcessors());\n  prop(this, '__compressors__',       Mincer.getCompressors());\n  prop(this, '__configurations__',    Mincer.getConfigurations());\n\n  // append paths\n  _.forEach(Mincer.paths, function (path) {\n    this.appendPath(path);\n  }, this);\n\n  // append default engines\n  _.forEach(this.getEngines(), function (klass, ext) {\n    this.addEngineToTrail(ext, klass);\n  }, this);\n\n  // register default mimeType extensions\n  _.forEach(this.__mimeTypes__.types, function (type, ext) {\n    this.__trail__.appendExtensions(ext);\n  }, this);\n\n\n  // internal cache\n  prop(this, '__assets__', {}, { writable: true });\n\n  // force drop cache\n  this.expireIndex();\n};\n\n\nrequire('util').inherits(Environment, Base);\n\n\n/**\n *  Environment#index -> Index\n *\n *  Returns a cached version of the environment.\n *\n *  All its file system calls are cached which makes `index` much\n *  faster. This behavior is ideal in production since the file\n *  system only changes between deploys.\n **/\ngetter(Environment.prototype, 'index', function () {\n  return new Index(this);\n});\n\n\n/**\n *  Environment#findAsset(path[, options]) -> Asset\n *\n *  Proxies call to [[Index#findAsset]] of the one time [[Environment#index]]\n *  instance. [[Index#findAsset]] automatically pushes cache here.\n **/\nEnvironment.prototype.findAsset = function (path, options) {\n  var asset;\n\n  options = options || {};\n  options.bundle = (typeof options.bundle === 'undefined') ? true : !!options.bundle;\n\n  // Ensure inmemory cached assets are still fresh on every lookup\n  asset = this.__assets__[this.cacheKeyFor(path, options)];\n\n  if (asset && asset.isFresh(this)) {\n    return asset;\n  }\n\n  // Cache is pushed upstream by Index#find_asset\n  return this.index.findAsset(path, options);\n};\n\n\n/** internal\n *  Environment#expireIndex() -> Void\n *\n *  Reset assets internal cache.\n **/\nEnvironment.prototype.expireIndex = function () {\n  this.__assets__ = {};\n};\n\n\n/**\n *  Environment#registerHelper(name, func) -> Void\n *  Environment#registerHelper(helpers) -> Void\n *\n *  Proxy to [[Context.registerHelper]] of current [[Environment#ContextClass]].\n *\n *\n *  ##### Example\n *\n *      env.registerHelper('foo', function () {});\n *\n *      // shorthand syntax of\n *\n *      env.ContextClass.registerHelper('foo', function () {});\n **/\nEnvironment.prototype.registerHelper = function () {\n  this.ContextClass.registerHelper.apply(null, arguments);\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/base.js":"/** internal\n *  class Base\n *\n *  Base class for [[Environment]] and [[Index]].\n *\n *\n *  ##### INCLUDES\n *\n *  - [[Engines]]\n *  - [[Mime]]\n *  - [[Processing]]\n *  - [[Paths]]\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar fs      = require('fs');\nvar path    = require('path');\nvar crypto  = require('crypto');\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n// internal\nvar getter          = require('./common').getter;\nvar prop            = require('./common').prop;\nvar mixin           = require('./common').mixin;\nvar isAbsolute      = require('./common').isAbsolute;\nvar VERSION         = require('./version');\nvar AssetAttributes = require('./asset_attributes');\nvar StaticAsset     = require('./assets/static');\nvar ProcessedAsset  = require('./assets/processed');\nvar BundledAsset    = require('./assets/bundled');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new Base()\n **/\nvar Base = module.exports = function Base() {};\n\n\nmixin(Base.prototype, require('./helpers/paths'));\nmixin(Base.prototype, require('./helpers/mime'));\nmixin(Base.prototype, require('./helpers/caching'));\nmixin(Base.prototype, require('./helpers/processing'));\nmixin(Base.prototype, require('./helpers/compressing'));\nmixin(Base.prototype, require('./helpers/configuring'));\nmixin(Base.prototype, require('./helpers/engines'));\n\n\n// helper that defines property which fires expireIndex()\n// each time it gets changed\nfunction attr_with_expire_index(name, value) {\n  var __name__ = '__' + name + '__';\n\n  // set underlying value\n  prop(Base.prototype, __name__, value, { writable: true });\n\n  // provide getters/setter\n  Object.defineProperty(Base.prototype, name, {\n    get: function () {\n      return this[__name__];\n    },\n    set: function (val) {\n      this.expireIndex();\n      this[__name__] = val;\n    }\n  });\n}\n\n\n/**\n *  Base#cache -> Mixed\n *\n *  Cache backend.\n *\n *  Default: `null`.\n **/\nattr_with_expire_index('cache', null);\n\n\n/**\n *  Base#digestAlgorithm -> String\n *\n *  Digest algorithm: `sha1` or `md5`.\n *  See Node manual on `crypto` module.\n *\n *  Default: `md5`.\n **/\nattr_with_expire_index('digestAlgorithm', 'md5');\n\n\n/**\n *  Base#version -> String\n *\n *  Environment version.\n *\n *      environment.version = '2.0'\n **/\nattr_with_expire_index('version', '');\n\n\n/**\n *  Base#digest -> crypto.Hash\n *\n *  Returns a `crypto.Hash` instance for the `Environment`.\n *\n *  This value serves two purposes. If two `Environment`s have the\n *  same digest value they can be treated as equal. This is more\n *  useful for comparing environment states between processes rather\n *  than in the same. Two equal `Environment`s can share the same\n *  cached assets.\n *\n *  The value also provides a seed digest for all `Asset` digests.\n *  Any change in the environment digest will affect all of its assets.\n **/\ngetter(Base.prototype, 'digest', function () {\n  // Do not cache, so the caller can safely mutate it with `.update`\n  var digest = crypto.createHash(this.digestAlgorithm);\n\n  // Mixin Mincer release version and custom environment version.\n  // So any new releases will affect all your assets.\n  digest.update(VERSION,      'utf8');\n  digest.update(this.version, 'utf8');\n\n  return digest;\n});\n\n\n// helper that overrides defined method `name` with wrapper that expireIndex()\n// and calls `func` when provided before calling original method\nfunction func_proxy_with_expire_index(name, func) {\n  var orig = Base.prototype[name];\n\n  Base.prototype[name] = function () {\n    this.expireIndex();\n    if (func) {\n      func.apply(this, arguments);\n    }\n    orig.apply(this, arguments);\n  };\n}\n\n\n//\n// override [[Paths]] mixin methods\n//\n\nfunc_proxy_with_expire_index('prependPath');\nfunc_proxy_with_expire_index('appendPath');\nfunc_proxy_with_expire_index('clearPaths');\n\n//\n// override [[Mime]] mixin methods\n//\n\nfunc_proxy_with_expire_index('registerMimeType', function (mimeType, ext) {\n  this.__trail__.appendExtensions(ext);\n});\n\n//\n// override [[Engines]] mixin methods\n//\n\nfunc_proxy_with_expire_index('registerEngine', function (ext, klass) {\n  this.addEngineToTrail(ext, klass);\n});\n\n//\n// override [[Processing]] mixin methods\n//\n\nfunc_proxy_with_expire_index('registerPreprocessor');\nfunc_proxy_with_expire_index('registerPostprocessor');\nfunc_proxy_with_expire_index('registerBundleProcessor');\nfunc_proxy_with_expire_index('unregisterPreprocessor');\nfunc_proxy_with_expire_index('unregisterPostprocessor');\nfunc_proxy_with_expire_index('unregisterBundleProcessor');\n\n\n/**\n *  Base#resolve(logicalPath[, options = {}[, fn]]) -> String\n *  - logicalPath (String)\n *  - options (Object)\n *  - fn (Function)\n *\n *  Finds the expanded real path for a given logical path by\n *  searching the environment's paths.\n *\n *      env.resolve(\"application.js\")\n *      # => \"/path/to/app/javascripts/application.js.coffee\"\n *\n *  An Error with `code = 'FileNotFound'` is raised if the file does not exist.\n **/\nBase.prototype.resolve = function (logicalPath, options, fn) {\n  var err, resolved, search;\n\n  if (fn) {\n    search = this.attributesFor(logicalPath).searchPaths;\n    return this.__trail__.find(search, options, function (pathname) {\n      var bower, extname;\n\n      if (!_.contains([ 'component.json', 'bower.json' ], path.basename(pathname))) {\n        return fn(pathname);\n      }\n\n      bower = require(pathname);\n\n      if (_.isString(bower.main)) {\n        return fn(path.join(path.dirname(pathname), bower.main));\n      }\n\n      if (_.isArray(bower.main)) {\n        extname = path.extname(logicalPath);\n\n        _.forEach(bower.main, function (mainfile) {\n          if (extname === '' || extname === path.extname(mainfile)) {\n            return fn(path.join(path.dirname(pathname), mainfile));\n          }\n        });\n      }\n\n      return null;\n    });\n  }\n\n  resolved = this.resolve(logicalPath, options, function (pathname) {\n    return pathname;\n  });\n\n  if (!resolved) {\n    err = new Error('Could not find file \\'' + logicalPath + '\\'');\n    err.code = 'FileNotFound';\n    throw err;\n  }\n\n  return resolved;\n};\n\n\n/**\n *  Base#entries(pathname) -> Array\n *  - pathname (String)\n *\n *  Proxy to `Hike.Trail#entries`. Works like `fs.readdirSync`.\n *  Subclasses may cache this method.\n **/\nBase.prototype.entries = function (pathname) {\n  return this.__trail__.entries(pathname);\n};\n\n\n/**\n *  Base#stat(pathname) -> fs.Stats\n *  - pathname (String)\n *\n *  Proxy to `Hike.Trail#stat`. Works like `fs.statSync`.\n *  Subclasses may cache this method.\n **/\nBase.prototype.stat = function (pathname) {\n  return this.__trail__.stat(pathname);\n};\n\n\n/**\n *  Base#getFileDigest(pathname) -> String\n *  - pathname (String)\n *\n *  Read and compute digest of filename.\n *  Subclasses may cache this method.\n **/\nBase.prototype.getFileDigest = function (pathname) {\n  var stat = this.stat(pathname);\n\n  if (stat && stat.isDirectory()) {\n    // If directory, digest the list of filenames\n    return this.digest.update(this.entries(pathname).join(',')).digest('hex');\n  }\n\n  // If file, digest the contents\n  return this.digest.update(fs.readFileSync(pathname)).digest('hex');\n};\n\n\n/** internal\n *  Base#attributesFor(pathname) -> AssetAttributes\n *  - pathname (String)\n *\n *  Returns a `AssetAttributes` for `pathname`\n **/\nBase.prototype.attributesFor = function (pathname) {\n  return new AssetAttributes(this, pathname);\n};\n\n\n/** internal\n *  Base#contentTypeOf(pathname) -> String\n *  - pathname (String)\n *\n *  Returns content type of `pathname`\n **/\nBase.prototype.contentTypeOf = function (pathname) {\n  return this.attributesFor(pathname).contentType;\n};\n\n\n/**\n *  Base#findAsset(pathname[, options = {}]) -> Asset|Null\n *  - pathname (String)\n *  - options (Object)\n *\n *  Find asset by logical path or expanded path.\n **/\nBase.prototype.findAsset = function (pathname, options) {\n  var logical_path = pathname, expanded_path;\n\n  if (isAbsolute(pathname)) {\n    if (!this.stat(pathname)) {\n      return null;\n    }\n\n    logical_path = this.attributesFor(pathname).logicalPath;\n  } else {\n    try {\n      pathname = this.resolve(logical_path);\n\n      if (path.extname(logical_path) === '') {\n        expanded_path = this.attributesFor(pathname).logicalPath;\n        logical_path += path.extname(expanded_path);\n      }\n    } catch (err) {\n      if (err.code === 'FileNotFound') {\n        return null;\n      }\n\n      throw err;\n    }\n  }\n\n  return this.buildAsset(logical_path, pathname, options);\n};\n\n\n/**\n *  Base#eachEntry(root, iterator) -> Void\n *  - root (String)\n *  - iterator (Function)\n *\n *  Calls `iterator` on each found file or directory in alphabetical order:\n *\n *      env.eachEntry('/some/path', function (entry) {\n *        console.log(entry);\n *      });\n *      // -> \"/some/path/a\"\n *      // -> \"/some/path/a/b.txt\"\n *      // -> \"/some/path/a/c.txt\"\n *      // -> \"/some/path/b.txt\"\n **/\nBase.prototype.eachEntry = function (root, iterator) {\n  var self = this, paths = [];\n\n  this.entries(root).forEach(function (filename) {\n    var pathname  = path.join(root, filename),\n        stats     = self.stat(pathname);\n\n    if (!stats) {\n      // File not found - silently skip it.\n      // It might happen only if we got \"broken\" symlink in real life.\n      // See https://github.com/nodeca/mincer/issues/18\n      return;\n    }\n\n    paths.push(pathname);\n\n    if (stats.isDirectory()) {\n      self.eachEntry(pathname, function (subpath) {\n        paths.push(subpath);\n      });\n    }\n  });\n\n  paths.sort().forEach(iterator);\n};\n\n\n/**\n *  Base#eachFile(iterator) -> Void\n *  - iterator (Function)\n *\n *  Calls `iterator` for each file found within all registered paths.\n **/\nBase.prototype.eachFile = function (iterator) {\n  var self = this;\n\n  this.paths.forEach(function (root) {\n    self.eachEntry(root, function (pathname) {\n      if (!self.stat(pathname).isDirectory()) {\n        iterator(pathname);\n      }\n    });\n  });\n};\n\n\n// Returns true if there were no filters, or `filename` matches at least one\nfunction matches_filter(filters, logicalPath, filename) {\n  if (filters.length === 0) {\n    return true;\n  }\n\n  return _.some(filters, function (filter) {\n    if (_.isRegExp(filter)) {\n      return filter.test(logicalPath);\n    }\n\n    if (_.isFunction(filter)) {\n      return filter(logicalPath, filename);\n    }\n\n    // prepare string to become RegExp.\n    // mimics shell's globbing\n    filter = filter.toString().replace(/\\*\\*|\\*|\\?|\\\\.|\\./g, function (m) {\n      if (m[0] === '*') {\n        return m === '**' ? '.+?' : '[^/]+?';\n      }\n\n      if (m[0] === '?') {\n        return '[^/]?';\n      }\n\n      if (m[0] === '.') {\n        return '\\\\.';\n      }\n\n      // handle `\\\\.` part\n      return m;\n    });\n\n    // prepare RegExp\n    filter = new RegExp('^' + filter + '$');\n    return filter.test(logicalPath);\n  });\n}\n\n\n// Returns logicalPath for `filename` if it matches given filters\nfunction logical_path_for_filename(self, filename, filters) {\n  var logical_path = self.attributesFor(filename).logicalPath;\n\n  if (matches_filter(filters, logical_path, filename)) {\n    return logical_path;\n  }\n\n  // If filename is an index file, retest with alias\n  if (path.basename(filename).split('.').shift() === 'index') {\n    logical_path = logical_path.replace(/\\/index\\./, '.');\n    if (matches_filter(filters, logical_path, filename)) {\n      return logical_path;\n    }\n  }\n}\n\n\n/**\n *  Base#eachLogicalPath(filters, iterator) -> Void\n *  - filters (Array)\n *  - iterator (Function)\n *\n *  Calls `iterator` on each found logical path (once per unique path) that\n *  matches at least one of the given filters.\n *\n *  Each filter might be a `String`, `RegExp` or a `Function`.\n **/\nBase.prototype.eachLogicalPath = function (filters, iterator) {\n  var self = this, files = {};\n\n  this.eachFile(function (filename) {\n    var logical_path = logical_path_for_filename(self, filename, filters);\n    if (logical_path && !files[logical_path]) {\n      iterator(logical_path, filename);\n      files[logical_path] = true;\n    }\n  });\n};\n\n\n// circular call  protection helper.\n// keeps array of required pathnames until the function\n// that originated protection finishes it's execution\nvar circular_calls = null;\n\n\nfunction circular_call_protection(pathname, callback) {\n  var reset = (circular_calls === null),\n      calls = circular_calls || (circular_calls = []);\n\n  try {\n    if (calls.indexOf(pathname) >= 0) {\n      throw new Error('Circular dependency detected: ' + pathname +\n                      ' has already been required');\n    }\n\n    calls.push(pathname);\n    return callback();\n  } finally {\n    if (reset) {\n      circular_calls = null;\n    }\n  }\n}\n\n\n// creates instance of [[StaticAsset]], [[BundledAsset]] or [[ProcessedAsset]]\nBase.prototype.buildAsset = function (logicalPath, pathname, options) {\n  var self = this;\n\n  options = options || {};\n\n  // If there are any processors to run on the pathname, use\n  // `BundledAsset`. Otherwise use `StaticAsset` and treat is as binary.\n\n  if (this.attributesFor(pathname).processors.length === 0) {\n    return new StaticAsset(this.index, logicalPath, pathname);\n  }\n\n  if (options.bundle) {\n    return new BundledAsset(this.index, logicalPath, pathname);\n  }\n\n  return circular_call_protection(pathname, function () {\n    return new ProcessedAsset(self.index, logicalPath, pathname);\n  });\n};\n\n\n// Returns cache key for given `pathname` based on options\nBase.prototype.cacheKeyFor = function (pathname, options) {\n  return pathname + String(options.bundle ? 1 : 0);\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/version.js":"'use strict';\n\n\n// Mincer version\nmodule.exports = require('../../package.json').version;\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/asset_attributes.js":"/** internal\n *  class AssetAttributes\n *\n *  `AssetAttributes` is a wrapper similar to Rubie's `Pathname` that provides\n *  some helper accessors.\n *\n *  These methods should be considered internalish.\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar path = require('path');\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n// internal\nvar prop   = require('./common').prop;\nvar getter = require('./common').getter;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new AssetAttributes(environment, pathanme)\n **/\nvar AssetAttributes = module.exports = function AssetAttributes(environment, pathname) {\n  prop(this, 'environment', environment);\n  prop(this, 'pathname',    pathname);\n};\n\n\n/**\n *  AssetAttributes#searchPaths -> Array\n *\n *  Returns paths search the load path for.\n **/\ngetter(AssetAttributes.prototype, 'searchPaths', function () {\n  var paths = [ this.pathname ],\n      exts  = this.extensions.join(''),\n      path_without_extensions;\n\n  path_without_extensions = this.extensions.reduce(function (p, ext) {\n    return p.replace(ext, '');\n  }, this.pathname);\n\n  // optimization: bower.json can only be nested one level deep\n  if (path_without_extensions.indexOf(path.sep) === -1) {\n    paths.push(path.join(path_without_extensions, 'bower.json'));\n  }\n\n  if (path.basename(this.pathname, exts) !== 'index') {\n    paths.push(path.join(path_without_extensions, 'index' + exts));\n  }\n\n  return paths;\n});\n\n\n\n/**\n *  AssetAttributes#logicalPath -> String\n *\n *  Reverse guess logical path for fully expanded path.\n *\n *  This has some known issues. For an example if a file is\n *  shaddowed in the path, but is required relatively, its logical\n *  path will be incorrect.\n **/\ngetter(AssetAttributes.prototype, 'logicalPath', function () {\n  var pathname = this.pathname,\n      paths = this.environment.paths,\n      unix_path = pathname.replace(/\\\\/g, '/'),\n      root_path;\n\n  root_path = _.find(paths, function (root) {\n    root = path.join(root, '/').replace(/\\\\/g, '/');\n    return root === unix_path.substr(0, root.length);\n  });\n\n  if (!root_path) {\n    throw new Error('File outside paths: ' + pathname + ' isn\\'t in paths: ' +\n                    paths.join(', '));\n  }\n\n  pathname = pathname.replace(root_path + path.sep, '');\n  pathname = pathname.replace(/\\\\/g, '/');\n  pathname = this.engineExtensions.reduce(function (p, ext) {\n    return p.replace(ext, '');\n  }, pathname);\n\n  if (!this.formatExtension) {\n    pathname += (this.engineFormatExtension || '');\n  }\n\n  return pathname;\n});\n\n\n/**\n *  AssetAttributes#relativePath -> String\n *\n *  Returns full path name relative to environment's root.\n **/\ngetter(AssetAttributes.prototype, 'relativePath', function () {\n  var root = this.environment.root, pathname = String(this.pathname);\n\n  if (root === pathname.substr(0, root.length)) {\n    return pathname.substr(root.length);\n  }\n  return pathname;\n});\n\n\n/**\n *  AssetAttributes#extensions -> Array\n *\n *  Returns `Array` of extension `String`s.\n *\n *      \"foo.js.coffee\"\n *      // -> [\".js\", \".coffee\"]\n **/\ngetter(AssetAttributes.prototype, 'extensions', function () {\n  var extensions;\n\n  if (!this.__extensions__) {\n    extensions = path.basename(this.pathname).split('.').slice(1);\n    prop(this, '__extensions__', extensions.map(function (ext) {\n      return '.' + ext;\n    }));\n  }\n\n\n  return this.__extensions__.slice();\n});\n\n\n/**\n *  AssetAttributes#formatExtension -> String\n *\n *  Returns the format extension.\n *\n *      \"foo.js.coffee\"\n *      // -> \".js\"\n **/\ngetter(AssetAttributes.prototype, 'formatExtension', function () {\n  return _.find(this.extensions.reverse(), function (ext) {\n    return this.getMimeType(ext) && !this.getEngines(ext);\n  }, this.environment);\n});\n\n\n/**\n *  AssetAttributes#engineExtension -> Array\n *\n *  Returns an `Array` of engine extensions.\n *\n *      \"foo.js.coffee.ejs\"\n *      // -> [\".coffee\", \".ejs\"]\n **/\ngetter(AssetAttributes.prototype, 'engineExtensions', function () {\n  var env     = this.environment,\n      exts    = this.extensions,\n      offset  = exts.indexOf(this.formatExtension);\n\n  if (offset >= 0) {\n    exts = exts.slice(offset + 1);\n  }\n\n  return _.filter(exts, function (ext) { return !!env.getEngines(ext); });\n});\n\n\n/**\n *  AssetAttributes#engines -> Array\n *\n *  Returns an array of engine classes.\n **/\ngetter(AssetAttributes.prototype, 'engines', function () {\n  var env = this.environment;\n  return this.engineExtensions.map(function (ext) { return env.getEngines(ext); });\n});\n\n\n/**\n *  AssetAttributes#processors -> Array\n *\n *  Returns all processors to run on the path.\n **/\ngetter(AssetAttributes.prototype, 'processors', function () {\n  return [].concat(this.environment.getPreProcessors(this.contentType),\n                   this.engines.reverse(),\n                   this.environment.getPostProcessors(this.contentType));\n});\n\n\n/**\n *  AssetAttributes#contentType -> String\n *\n *  Returns the content type for the pathname.\n *  Falls back to `application/octet-stream`.\n **/\ngetter(AssetAttributes.prototype, 'contentType', function () {\n  var mime_type;\n\n  if (!this.__contentType__) {\n    mime_type = this.engineContentType || 'application/octet-stream';\n\n    if (this.formatExtension) {\n      mime_type = this.environment.getMimeType(this.formatExtension, mime_type);\n    }\n\n    prop(this, '__contentType__', mime_type);\n  }\n\n  return this.__contentType__;\n});\n\n\n/**\n *  AssetAttributes#engineContentType -> String\n *\n *  Returns implicit engine content type.\n *\n *  `.coffee` files carry an implicit `application/javascript`\n *  content type.\n **/\ngetter(AssetAttributes.prototype, 'engineContentType', function () {\n  var engine = _.find(this.engines.reverse(), function (engine) {\n    return !!engine.defaultMimeType;\n  });\n\n  return (engine || {}).defaultMimeType;\n});\n\n\n/**\n *  AssetAttributes#engineFormatExtension -> String\n *\n *  Returns implicit engine extension.\n *\n *  `.coffee` files carry an implicit `.js` extension (due to it's implicit\n *  content type of `application/javascript`).\n **/\ngetter(AssetAttributes.prototype, 'engineFormatExtension', function () {\n  var type = this.engineContentType;\n  if (type) {\n    return this.environment.getExtensionForMimeType(type);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/assets/static.js":"/** internal\n *  class StaticAsset\n *\n *  Represents static asset the one that has no any processors associated with.\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Asset]]\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar fs = require('fs');\n\n\n// internal\nvar prop    = require('../common').prop;\nvar getter  = require('../common').getter;\nvar Asset   = require('./asset');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new StaticAsset()\n *\n *  See [[Asset.new]] for details.\n **/\nvar StaticAsset = module.exports = function StaticAsset() {\n  Asset.apply(this, arguments);\n  prop(this, 'type', 'static');\n};\n\n\nrequire('util').inherits(StaticAsset, Asset);\n\n\n// See apidoc of [[Asset#buffer]]\ngetter(StaticAsset.prototype, 'buffer', function () {\n  // No caching to avoid memory bloating by default.\n  // Caching might be implemented on the higher level (e.g. in [[Server]])\n  // by simply setting `__buffer__` property.\n  return this.__buffer__ || fs.readFileSync(this.pathname);\n});\n\n\n// See apidoc of [[Asset#source]]\ngetter(StaticAsset.prototype, 'source', function () {\n  return this.buffer.toString('binary');\n});\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/assets/asset.js":"/** internal\n *  class Asset\n *\n *  The base class for [[BundledAsset]], [[ProcessedAsset]] and [[StaticAsset]].\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar path = require('path');\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n// internal\nvar prop   = require('../common').prop;\nvar getter = require('../common').getter;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar TYPE_TO_KLASS_CACHE = {};\n\n\nfunction typeToClass(type) {\n  if (!TYPE_TO_KLASS_CACHE[type]) {\n    TYPE_TO_KLASS_CACHE[type] = require('./' + type);\n  }\n\n  return TYPE_TO_KLASS_CACHE[type];\n}\n\n\n/**\n *  new Asset(environment, logicalPath, pathname)\n *  - environment (Environment)\n *  - logicalPath (String)\n *  - pathname (String)\n **/\nvar Asset = module.exports = function Asset(environment, logicalPath, pathname) {\n  var mtime;\n\n  if (path.extname(logicalPath) === '') {\n    throw new Error('Asset logical path has no extension: ' + logicalPath);\n  }\n\n\n  // drop mtime to 1 second\n  mtime = environment.stat(pathname).mtime;\n  mtime = new Date(parseInt(mtime.getTime() / 1000, 10) * 1000);\n\n  prop(this, 'root',          environment.root);\n  prop(this, 'environment',   environment);\n  prop(this, 'logicalPath',   logicalPath);\n  prop(this, 'pathname',      pathname);\n  prop(this, 'contentType',   environment.contentTypeOf(pathname));\n  prop(this, 'mtime',         mtime, { writable: true });\n  prop(this, 'length',        environment.stat(pathname).size, { writable: true });\n  prop(this, 'digest',        environment.getFileDigest(pathname), { writable: true });\n\n  prop(this, '__requiredAssets__',  [], { writable: true });\n  prop(this, '__dependencyPaths__', [], { writable: true });\n};\n\n\n// helper to sub-out getters of Asset.prototype\nfunction stub_getter(name) {\n  getter(Asset.prototype, name, function () {\n    // this should never happen, as Asset is an abstract class and not\n    // supposed to be used directly. subclasses must override this getters\n    throw new Error(this.constructor.name + '#' + name + ' getter is not implemented.');\n  });\n}\n\n\n/**\n *  Asset#buffer -> Buffer\n *\n *  `Buffer` content of asset.\n **/\nstub_getter('buffer');\n\n\n/**\n *  Asset#source -> String\n *\n *  `String` (concatenated) content of asset.\n **/\nstub_getter('source');\n\n\n/**\n *  Asset#digestPath -> String\n *\n *  Return logical path with digest spliced in.\n *\n *      \"foo/bar-ce09b59f734f7f5641f2962a5cf94bd1.js\"\n **/\ngetter(Asset.prototype, 'digestPath', function () {\n  var ext = path.extname(this.logicalPath),\n      sfx = '-' + this.digest + ext;\n  return this.logicalPath.replace(new RegExp(ext + '$'), sfx);\n});\n\n\n/**\n *  Asset#toArray() -> Array\n *\n *  Expand asset into an `Array` of parts.\n *\n *  Appending all of an assets body parts together should give you\n *  the asset's contents as a whole.\n **/\nAsset.prototype.toArray = function () {\n  return [ this ];\n};\n\n\n/** alias of: Asset#source\n *  Asset#toString() -> String\n **/\nAsset.prototype.toString = function () {\n  return this.source;\n};\n\n\n/**\n *  Asset.isDependencyFresh(environment, dep) -> Boolean\n *  - environment (Environment|Index)\n *  - dep (Asset)\n *\n *  Returns whenever given `dep` asset is fresh by checking it's mtime, and\n *  contents if it's match.\n **/\nAsset.isDependencyFresh = function (environment, dep) {\n  var stat = environment.stat(dep.pathname);\n\n  // If path no longer exists, its definitely stale.\n  if (!stat) {\n    return false;\n  }\n\n  // Compare dependency mime to the actual mtime. If the\n  // dependency mtime is newer than the actual mtime, the file\n  // hasn't changed since we created this `Asset` instance.\n  //\n  // However, if the mtime is newer it doesn't mean the asset is\n  // stale. Many deployment environments may recopy or recheckout\n  // assets on each deploy. In this case the mtime would be the\n  // time of deploy rather than modified time.\n  if (dep.mtime.getTime() >= stat.mtime.getTime()) {\n    return true;\n  }\n\n  // If the mtime is newer, do a full digest comparsion.\n  // Return fresh if the digests match. Otherwise, its stale.\n  return (dep.digest === environment.getFileDigest(dep.pathname));\n};\n\n\n/**\n *  Asset#isFresh(environment) -> Boolean\n *  - environment (Environment|Index)\n *\n *  Checks if Asset is fresh by comparing the actual mtime and\n *  digest to the inmemory model.\n *\n *  Used to test if cached models need to be rebuilt.\n **/\nAsset.prototype.isFresh = function (environment) {\n  return Asset.isDependencyFresh(environment, this);\n};\n\n\n/** internal\n *  Asset#dependencyPaths -> Array\n *\n *  String paths that are marked as dependencies after processing.\n *  Default to an empty `Array`.\n **/\ngetter(Asset.prototype, 'dependencyPaths', function () {\n  return this.__dependencyPaths__.slice();\n});\n\n\n/** internal\n *  Asset#requiredAssets -> Array\n *\n *  `ProcessedAsset`s that are required after processing.\n *  Default to an empty `Array`.\n **/\ngetter(Asset.prototype, 'requiredAssets', function () {\n  return this.__requiredAssets__.slice();\n});\n\n\n/**\n *  Asset#relativePath -> String\n *\n *  Returns AssetAttributes#relativePath of current file.\n **/\ngetter(Asset.prototype, 'relativePath', function () {\n  return this.environment.attributesFor(this.pathname).relativePath;\n});\n\n\nAsset.prototype.relativizeRootPath = function (pathname) {\n  pathname = String(pathname);\n\n  if (this.root === pathname.substr(0, this.root.length)) {\n    return '$root' + pathname.substr(this.root.length);\n  }\n  return pathname;\n};\n\n\n\nAsset.prototype.expandRootPath = function (pathname) {\n  return String(pathname).replace(/^\\$root/, this.root);\n};\n\n\nAsset.prototype.encodeWith = function (hash) {\n  hash.type        = this.type;\n  hash.logicalPath = this.logicalPath;\n  hash.pathname    = this.relativizeRootPath(this.pathname);\n  hash.contentType = this.contentType;\n  hash.mtime       = this.mtime.getTime();\n  hash.length      = this.length;\n  hash.digest      = this.digest;\n};\n\n\nAsset.prototype.initWith = function (environment, hash) {\n  prop(this, 'root',          environment.root);\n  prop(this, 'environment',   environment);\n  prop(this, 'logicalPath',   hash.logicalPath);\n  prop(this, 'pathname',      this.expandRootPath(hash.pathname));\n  prop(this, 'contentType',   hash.contentType);\n  prop(this, 'mtime',         new Date(hash.mtime), { writable: true });\n  prop(this, 'length',        hash.length, { writable: true });\n  prop(this, 'digest',        hash.digest, { writable: true });\n\n  prop(this, '__requiredAssets__',  [], { writable: true });\n  prop(this, '__dependencyPaths__', [], { writable: true });\n};\n\n\nAsset.fromHash = function (environment, hash) {\n  try {\n    var asset, klass;\n\n    if (_.isPlainObject(hash)) {\n      klass = typeToClass(hash.type);\n\n      if (klass) {\n        asset = Object.create(klass.prototype);\n        prop(asset, 'type', hash.type); // KLUDGE: Use constructor.name\n        asset.initWith(environment, hash);\n      }\n    }\n\n    return asset;\n  } catch (e) {\n    if (e.code === 'unserialize_error') {\n      // do nothing\n      return null;\n    }\n\n    throw e;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/assets/processed.js":"/** internal\n *  class ProcessedAsset\n *\n *  `ProcessedAsset`s are internal representation of processable files.\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Asset]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n// internal\nvar prop    = require('../common').prop;\nvar getter  = require('../common').getter;\nvar Asset   = require('./asset');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// internal class used to build dependency graph\nfunction DependencyFile(pathname, mtime, digest) {\n  this.pathname = pathname;\n  this.mtime    = mtime;\n  this.digest   = digest;\n}\n\n\n// recursively iterate over all requried assets,\n// gather a list of (compiling if needed) assets that should be required\nfunction resolveDependencies(self, paths) {\n  var assets = [], cache = {};\n\n  _.forEach(paths, function (p) {\n    var asset;\n\n    if (p === self.pathname) {\n      if (!cache[p]) {\n        cache[p] = true;\n        assets.push(self);\n      }\n      return;\n    }\n\n    asset = self.environment.findAsset(p, { bundle: false });\n\n    if (asset) {\n      asset.__requiredAssets__.forEach(function (asset_dependency) {\n        if (!cache[asset_dependency.pathname]) {\n          cache[asset_dependency.pathname] = true;\n          assets.push(asset_dependency);\n        }\n      });\n    }\n  });\n\n  return assets;\n}\n\n\n// build all required assets\nfunction buildRequiredAssets(self, context) {\n  var paths   = context.__requiredPaths__.concat([ self.pathname ]),\n      assets  = resolveDependencies(self, paths),\n      stubs   = resolveDependencies(self, context.__stubbedAssets__);\n\n  if (stubs.length > 0) {\n    // exclude stubbed assets if any\n    assets = _.filter(assets, function (path) {\n      return stubs.indexOf(path) === -1;\n    });\n  }\n\n  prop(self, '__requiredAssets__', assets);\n}\n\n\n// prepare an ordered list (map) of dependencies\nfunction buildDependencyPaths(self, context) {\n  var dependencies = {};\n\n  context.__dependencyPaths__.forEach(function (p) {\n    var dep = new DependencyFile(p, self.environment.stat(p).mtime,\n                                 self.environment.getFileDigest(p));\n    dependencies[JSON.stringify(dep)] = dep;\n  });\n\n  _.forEach(context.__dependencyAssets__, function (p) {\n    var dep, asset;\n\n    if (p === self.pathname) {\n      dep = new DependencyFile(p, self.environment.stat(p).mtime,\n                               self.environment.getFileDigest(p));\n      dependencies[JSON.stringify(dep)] = dep;\n      return;\n    }\n\n    asset = self.environment.findAsset(p, { bundle: false });\n\n    if (asset) {\n      asset.dependencyPaths.forEach(function (dep) {\n        dependencies[JSON.stringify(dep)] = dep;\n      });\n    }\n  });\n\n  prop(self, '__dependencyPaths__', _.values(dependencies));\n}\n\n\n// return digest based on digests of all dependencies\nfunction computeDependencyDigest(self) {\n  return _.reduce(self.requiredAssets, function (digest, asset) {\n    return digest.update(asset.digest);\n  }, self.environment.digest).digest('hex');\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new ProcessedAsset()\n *\n *  See [[Asset.new]] for details.\n **/\nvar ProcessedAsset = module.exports = function ProcessedAsset() {\n  var Klass, context, result;\n\n  Asset.apply(this, arguments);\n  prop(this, 'type', 'processed');\n\n  // prepare to build ourself\n  Klass       = this.environment.ContextClass;\n  context     = new Klass(this.environment, this.logicalPath, this.pathname);\n\n  result          = context.evaluate(this.pathname);\n  this.__source__ = result.data;\n  this.sourceMap  = result.map;\n\n  this.length = Buffer.byteLength(this.source);\n  this.digest = this.environment.digest.update(this.source).digest('hex');\n\n  buildRequiredAssets(this, context);\n  buildDependencyPaths(this, context);\n\n  prop(this, 'dependencyDigest', computeDependencyDigest(this));\n};\n\n\nrequire('util').inherits(ProcessedAsset, Asset);\n\n\n/**\n *  ProcessedAsset#isFresh(environment) -> Boolean\n *  - environment (Environment|Index)\n *\n *  Checks if Asset is stale by comparing the actual mtime and\n *  digest to the inmemory model.\n **/\nProcessedAsset.prototype.isFresh = function (environment) {\n  return _.every(this.__dependencyPaths__, function (dep) {\n    return Asset.isDependencyFresh(environment, dep);\n  });\n};\n\n\n// See apidoc of [[Asset#buffer]]\ngetter(ProcessedAsset.prototype, 'buffer', function () {\n  return this.__buffer__ || new Buffer(this.source);\n});\n\n\n// See apidoc of [[Asset#source]]\ngetter(ProcessedAsset.prototype, 'source', function () {\n  return this.__source__;\n});\n\n\nProcessedAsset.prototype.encodeWith = function (hash) {\n  Asset.prototype.encodeWith.call(this, hash);\n\n  hash.source            = this.__source__;\n  hash.sourceMap         = this.sourceMap;\n  hash.dependencyDigest  = this.dependencyDigest;\n\n  hash.requiredPaths = this.__requiredAssets__.map(function (asset) {\n    return this.relativizeRootPath(asset.pathname);\n  }, this);\n\n\n  hash.dependencyPaths = this.__dependencyPaths__.map(function (dep) {\n    return {\n      path:   this.relativizeRootPath(dep.pathname),\n      mtime:  dep.mtime.getTime(),\n      digest: dep.digest\n    };\n  }, this);\n};\n\n\n\nProcessedAsset.prototype.initWith = function (environment, hash) {\n  Asset.prototype.initWith.call(this, environment, hash);\n\n  this.__source__ = hash.source;\n  this.sourceMap  = hash.sourceMap;\n\n  prop(this, 'dependencyDigest', hash.dependencyDigest);\n\n  prop(this, '__requiredAssets__', hash.requiredPaths.map(function (p) {\n    var root;\n\n    p     = this.expandRootPath(p);\n    root  = _.find(environment.paths, function (path) {\n      return path === p.substr(0, path.length);\n    }, this);\n\n    if (!root) {\n      throw {\n        code:     'unserialize_error',\n        message:  p + ' isn\\'t in paths'\n      };\n    }\n\n    return p === this.pathname ? this : environment.findAsset(p, { bundle: false });\n  }, this));\n\n  prop(this, '__dependencyPaths__', hash.dependencyPaths.map(function (h) {\n    return new DependencyFile(this.expandRootPath(h.path), new Date(h.mtime), h.digest);\n  }, this));\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/assets/bundled.js":"/** internal\n *  class BundledAsset\n *\n *  `BundledAsset`s are used for files that need to be processed and\n *  concatenated with other assets, e.g. .js` and `.css` files.\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Asset]]\n **/\n\n\n'use strict';\n\n\n// 3rd-party\nvar _         = require('lodash');\nvar sourcemap = require('source-map');\nvar path      = require('path');\n\n\n// internal\nvar prop    = require('../common').prop;\nvar getter  = require('../common').getter;\nvar Asset   = require('./asset');\n\nfunction mapify(path) {\n  return path.sep === '\\\\' ? path.replace('\\\\', '/') : path;\n}\n\nfunction shiftPaths(map, relativePath) {\n  map.sources.forEach(function (file, idx) {\n    map.sources[idx] = mapify(path.normalize(path.join(relativePath, file)));\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new BundledAsset()\n *\n *  See [[Asset.new]] for details.\n **/\nvar BundledAsset = module.exports = function BundledAsset() {\n  var processedAsset, Klass, context, processors, options, result,\n      source = '', sourceMap = '', resultSourceNode;\n\n  Asset.apply(this, arguments);\n  prop(this, 'type', 'bundled');\n\n  processedAsset = this.environment.findAsset(this.pathname, { bundle: false });\n\n  prop(this, '__processedAsset__',  processedAsset);\n  prop(this, '__requiredAssets__',  processedAsset.__requiredAssets__);\n  prop(this, '__dependencyPaths__', processedAsset.__dependencyPaths__);\n\n  // moved from the end just to use context helper function\n  Klass       = this.environment.ContextClass;\n  context     = new Klass(this.environment, this.logicalPath, this.pathname);\n\n\n  if (!this.environment.isEnabled('source_maps')) {\n    this.toArray().forEach(function (dep) {\n      source += dep.toString();\n    });\n  } else {\n\n    var baseDir = path.dirname(this.pathname);\n    resultSourceNode = new sourcemap.SourceNode(\n                              null,\n                              null,\n                              path.basename(this.pathname)\n                            );\n\n    this.toArray().forEach(function (dep) {\n      var map = context.createSourceMapObject({\n        data: dep.toString(),\n        map:  dep.sourceMap,\n        file: dep.pathname\n      });\n\n      // Convert dependency paths to be relative to current dir\n      shiftPaths(map, path.relative(baseDir, path.dirname(dep.pathname)));\n\n      var depSourceNone = sourcemap.SourceNode.fromStringWithSourceMap(\n                            dep.toString(),\n                            new sourcemap.SourceMapConsumer(map)\n                          );\n      resultSourceNode.add(depSourceNone);\n    });\n\n    result = resultSourceNode.toStringWithSourceMap();\n    sourceMap = result.map.toString();\n    source = result.code;\n  }\n\n  // prepare to build ourself\n  processors  = this.environment.getBundleProcessors(this.contentType);\n  options     = { data: source, map: sourceMap, processors: processors };\n\n  result          = context.evaluate(this.pathname, options);\n  this.__source__ = result.data;\n\n  this.sourceMap = '';\n\n  if (result.map) {\n    // Here we have final map. Need to shift paths again,\n    // because all bundled assets are placed to env root\n    sourceMap = JSON.parse(result.map);\n    shiftPaths(sourceMap, path.dirname(path.relative(this.environment.root, this.pathname)));\n    // Set default root to avoid shifting. This var is easy to manipulate later.\n    sourceMap.sourceRoot = this.environment.sourceRoot;\n    this.sourceMap  = JSON.stringify(sourceMap);\n  }\n\n  this.mtime  = _.chain(this.toArray().concat(this.__dependencyPaths__))\n    .map(function (asset) { return new Date(Date.parse(asset.mtime)); })\n    .max()\n    .value();\n\n  this.length = Buffer.byteLength(this.source);\n  this.digest = this.environment.digest.update(this.source).digest('hex');\n};\n\n\nrequire('util').inherits(BundledAsset, Asset);\n\n\n// See apidoc of [[Asset#buffer]]\ngetter(BundledAsset.prototype, 'buffer', function () {\n  return this.__buffer__ || new Buffer(this.source);\n});\n\n\n// See apidoc of [[Asset#source]]\ngetter(BundledAsset.prototype, 'source', function () {\n  return this.__source__;\n});\n\n\n/**\n *  BundledAsset#dependencies -> Array\n *\n *  Return an `Array` of `Asset` files that are declared dependencies.\n **/\ngetter(BundledAsset.prototype, 'dependencies', function () {\n  return _.reject(this.toArray(), function (asset) {\n    return this.__processedAsset__ === asset;\n  }, this);\n});\n\n\n/**\n *  BundledAsset#toArray() -> Array\n *\n *  Return array of porcessed assets this asset contains of.\n **/\nBundledAsset.prototype.toArray = function () {\n  return this.__requiredAssets__;\n};\n\n\n/**\n *  BundledAsset#isFresh(environment) -> Boolean\n *  - environment (Environment|Index)\n *\n *  Checks if Asset is stale by comparing the actual mtime and\n *  digest to the inmemory model.\n **/\nBundledAsset.prototype.isFresh = function (environment) {\n  return this.__processedAsset__.isFresh(environment);\n};\n\n\nBundledAsset.prototype.encodeWith = function (hash) {\n  Asset.prototype.encodeWith.call(this, hash);\n\n  hash.source                = this.__source__;\n  hash.sourceMap             = this.sourceMap;\n  hash.requiredAssetsDigest  = this.__processedAsset__.dependencyDigest;\n};\n\n\nBundledAsset.prototype.initWith = function (environment, hash) {\n  Asset.prototype.initWith.call(this, environment, hash);\n\n  this.__source__ = hash.source;\n  this.sourceMap  = hash.sourceMap;\n\n  prop(this, '__processedAsset__',  environment.findAsset(this.pathname, { bundle: false }));\n  prop(this, '__requiredAssets__',  this.__processedAsset__.__requiredAssets__);\n\n  if (this.__processedAsset__.dependencyDigest !== hash.requiredAssetsDigest) {\n    throw {\n      code:     'unserialize_error',\n      message:  'processed asset belongs to a stale environment'\n    };\n  }\n};\n\n\nBundledAsset.prototype.mappingUrlComment = function () {\n  if (this.contentType === 'text/css') {\n    return '\\n/*# sourceMappingURL=' + path.basename(this.digestPath) + '.map' + ' */';\n  }\n  if (this.contentType === 'application/javascript') {\n    return '\\n//# sourceMappingURL=' + path.basename(this.digestPath) + '.map';\n  }\n  return '';\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/helpers/paths.js":"/** internal\n *  mixin Paths\n *\n *  An internal mixin whose public methods are exposed on the [[Environment]]\n *  and [[Index]] classes.\n *\n *  Provides helpers to work with `Hike.Trail` instance.\n **/\n\n\n// REQUIRED PROPERTIES /////////////////////////////////////////////////////////\n//\n// - `__trail__` (Hike.Trail)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n'use strict';\n\n\n// internal\nvar getter = require('../common').getter;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  Paths#root -> String\n *\n *  Returns [[Environment]] root.\n *\n *  All relative paths are expanded with root as its base.\n *  To be useful set this to your applications root directory.\n **/\ngetter(module.exports, 'root', function () {\n  return this.__trail__.__root__;\n});\n\n\n/**\n *  Paths#paths -> Array\n *\n *  Returns an `Array` of path `String`s.\n *\n *  These paths will be used for asset logical path lookups.\n *\n *  Note that a copy of the `Array` is returned so mutating will\n *  have no affect on the environment. See [[Paths#appendPath]],\n *  [[Paths#prependPath]], and [[Paths#clearPaths]].\n **/\ngetter(module.exports, 'paths', function () {\n  return this.__trail__.paths;\n});\n\n\n/**\n *  Paths#prependPath(path) -> Void\n *\n *  Prepend a `path` to the `paths` list.\n *  Paths at the end have the least priority.\n **/\nmodule.exports.prependPath = function (path) {\n  this.__trail__.prependPaths(path);\n};\n\n\n/**\n *  Paths#appendPath(path) -> Void\n *\n *  Append a `path` to the `paths` list.\n *  Paths at the beginning have a higher priority.\n **/\nmodule.exports.appendPath = function (path) {\n  this.__trail__.appendPaths(path);\n};\n\n\n/**\n *  Paths#clearPaths() -> Array\n *\n *  Clear all paths and start fresh.\n *\n *  There is no mechanism for reordering paths, so its best to\n *  completely wipe the paths list and reappend them in the order\n *  you want.\n *\n *  Returns list of previously registered paths.\n **/\nmodule.exports.clearPaths = function () {\n  return this.__trail__.removePaths();\n};\n\n\n/**\n *  Paths#extensions -> Array\n *\n *  Returns an `Array` of extensions.\n *\n *  These extensions maybe omitted from logical path searches.\n *\n *      [\".js\", \".css\", \".coffee\", \".sass\", ...]\n **/\ngetter(module.exports, 'extensions', function () {\n  return [].concat(this.__trail__.__extensions__);\n});\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/helpers/mime.js":"/** internal\n *  mixin Mime\n *\n *  An internal mixin whose public methods are exposed on the [[Environment]]\n *  and [[Index]] classes.\n *\n *  Provides helpers to deal with mime types.\n **/\n\n\n// REQUIRED PROPERTIES /////////////////////////////////////////////////////////\n//\n// - `__mimeTypes__` (Mimoza)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n'use strict';\n\n\n// 3rd-party\nvar Mimoza  = require('mimoza');\n\n\n// internal\nvar getter  = require('../common').getter;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  Mime#getMimeType(ext) -> String\n *\n *  Returns the mime type for the `extension`.\n **/\nmodule.exports.getMimeType = function (ext) {\n  return this.__mimeTypes__.getMimeType(ext) || Mimoza.getMimeType(ext);\n};\n\n\n/**\n *  Mime#registeredMimeTypes -> Mimoza\n *\n *  Returns a copy of `Mimoza` instance with explicitly registered mime types.\n **/\ngetter(module.exports, 'registeredMimeTypes', function () {\n  return this.__mimeTypes__.clone();\n});\n\n\n/**\n *  Mime#getExtensionForMimeType(type) -> String\n *\n *  Returns extension for mime `type`.\n **/\nmodule.exports.getExtensionForMimeType = function (type) {\n  return this.__mimeTypes__.getExtension(type) || Mimoza.getExtension(type);\n};\n\n\n/**\n *  Mime#registerMimeType(type, ext) -> Void\n *\n *  Register new mime type.\n **/\nmodule.exports.registerMimeType = function (mimeType, ext) {\n  this.__mimeTypes__.register(mimeType, ext);\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/helpers/caching.js":"/** internal\n *  mixin Caching\n *\n *  An internal mixin whose public methods are exposed on the [[Environment]]\n *  and [[Index]] classes.\n **/\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n'use strict';\n\n\n// stdlib\nvar join    = require('path').join;\nvar crypto  = require('crypto');\n\n\n// internal\nvar Asset = require('../assets/asset');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nfunction expandKey(self, key) {\n  key = String(key).replace(self.root, '');\n  key = crypto.createHash('md5').update(key, 'utf8').digest('hex');\n  return join('mincer', key);\n}\n\n\nfunction cacheSet(self, key, hash) {\n  hash._version = self.digest.digest('hex');\n  self.cache.set(expandKey(self, key), hash);\n}\n\n\nfunction cacheGet(self, key) {\n  var hash = self.cache.get(expandKey(self, key));\n  if (hash && hash._version === self.digest.digest('hex')) {\n    return hash;\n  }\n}\n\n\nmodule.exports.cacheAsset = function (path, fn) {\n  var asset, hash;\n\n  if (!this.cache) {\n    return fn();\n  }\n\n  asset = Asset.fromHash(this, cacheGet(this, path));\n  if (asset && asset.isFresh(this)) {\n    return asset;\n  }\n\n  asset = fn();\n  if (asset) {\n    hash = {};\n    asset.encodeWith(hash);\n\n    // Save the asset to its path\n    cacheSet(this, path, hash);\n\n    // Since path maybe a logical or full pathname, save the\n    // asset its its full path too\n    if (path !== asset.pathname) {\n      cacheSet(this, asset.pathname, hash);\n    }\n\n    return asset;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/helpers/processing.js":"/** internal\n *  mixin Processing\n *\n *  An internal mixin whose public methods are exposed on the [[Environment]]\n *  and [[Index]] classes.\n **/\n\n\n// REQUIRED MIXINS /////////////////////////////////////////////////////////////\n//\n// - [[Mime]]\n// - [[Paths]]\n//\n// REQUIRED PROPERTIES /////////////////////////////////////////////////////////\n//\n// - `__trail__` (Hike.Trail)\n// - `__preProcessors__` (Hash)\n// - `__postProcessors__` (Hash)\n// - `__bundleProcessors__` (Hash)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n'use strict';\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n// internal\nvar Processor = require('../processor');\nvar getter    = require('../common').getter;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  Processing#formatExtension -> Array\n *\n *  Returns an `Array` of format extension `String`s.\n *\n *      // => ['.js', '.css']\n **/\ngetter(module.exports, 'formatExtension', function () {\n  return _.difference(this.extensions, _.keys(this.engines));\n});\n\n\n/**\n *  Processing#getPreProcessors(mimeType = null) -> Array|Types.Hash\n *\n *  Returns an `Array` of `Processor` classes. If a `mime_type`\n *  argument is supplied, the processors registered under that\n *  extension will be returned.\n *\n *  Preprocessors are ran before Postprocessors and Engine\n *  processors.\n **/\nmodule.exports.getPreProcessors = function (mimeType) {\n  if (mimeType) {\n    return this.__preProcessors__.get(mimeType).slice();\n  }\n  return this.__preProcessors__.clone();\n};\n\n\n/**\n *  Processing#getPostProcessors(mimeType = null) -> Array|Types.Hash\n *\n *  Returns an `Array` of `Processor` classes. If a `mime_type`\n *  argument is supplied, the processors registered under that\n *  extension will be returned.\n *\n *  Postprocessors are ran after Preprocessors and Engine processors.\n **/\nmodule.exports.getPostProcessors = function (mimeType) {\n  if (mimeType) {\n    return this.__postProcessors__.get(mimeType).slice();\n  }\n  return this.__postProcessors__.clone();\n};\n\n\n/**\n *  Processing#getBundleProcessors(mimeType = null) -> Array|Types.Hash\n *\n *  Returns an `Array` of `Processor` classes. If a `mimeType`\n *  argument is supplied, the processors registered under that\n *  extension will be returned.\n *\n *  Bundle Processors are ran on concatenated assets rather than\n *  individual files.\n *\n *  All `Processor`s must follow the [[Template]] interface. It is\n *  recommended to subclass [[Template]].\n **/\nmodule.exports.getBundleProcessors = function (mimeType) {\n  if (mimeType) {\n    return this.__bundleProcessors__.get(mimeType).slice();\n  }\n  return this.__bundleProcessors__.clone();\n};\n\n\n/**\n *  Processing#registerPreProcessor(mimeType, klass[, fn]) -> Void\n *\n *  Registers a new preprocessor `klass` for `mime_type`.\n *\n *      registerPreprocessor('text/css', DirectiveProcessor);\n *\n *  A function can be passed for to create a shorthand processor.\n *\n *      registerPreProcessor('text/css', 'my_processor', function (context, data, callback) {\n *        callback(null, data.replace(...));\n *      });\n **/\nmodule.exports.registerPreProcessor = function (mimeType, klass, fn) {\n  var name;\n\n  if (fn) {\n    name  = klass;\n    klass = Processor.create(name, fn);\n  }\n\n  this.__preProcessors__.get(mimeType).push(klass);\n};\n\n\n/**\n *  Processing#registerPostProcessor(mimeType, klass[, fn]) -> Void\n *\n *  Registers a new Postprocessor `klass` for `mime_type`.\n *\n *      registerPostprocessor('text/css', DirectiveProcessor);\n *\n *  A function can be passed for to create a shorthand processor.\n *\n *      registerPostprocessor('text/css', 'my_processor', function (context, data, callback) {\n *        callback(null, data.replace(...));\n *      });\n **/\nmodule.exports.registerPostProcessor = function (mimeType, klass, fn) {\n  var name;\n\n  if (fn) {\n    name  = klass;\n    klass = Processor.create(name, fn);\n  }\n\n  this.__postProcessors__.get(mimeType).push(klass);\n};\n\n\n/**\n *  Processing#registerBundleProcessor(mimeType, klass[, fn]) -> Void\n *\n *  Registers a new BundleProcessor `klass` for `mime_type`.\n *\n *      registerBundleProcessor('text/css', CharsetNormalizer);\n *\n *  A function can be passed for to create a shorthand processor.\n *\n *      registerBundleProcessor('text/css', 'my_processor', function (context, data, callback) {\n *        callback(null, data.replace(...));\n *      });\n **/\nmodule.exports.registerBundleProcessor = function (mimeType, klass, fn) {\n  var name;\n\n  if (fn) {\n    name  = klass;\n    klass = Processor.create(name, fn);\n  }\n\n  this.__bundleProcessors__.get(mimeType).push(klass);\n};\n\n\n/**\n *  Processing#unregisterPreProcessor(mimeType, klass) -> Void\n *\n *  Remove Preprocessor `klass` for `mime_type`.\n *\n *      unregisterPreprocessor('text/css', DirectiveProcessor);\n **/\nmodule.exports.unregisterPreProcessor = function (mimeType, klass) {\n  var processors = this.__preProcessors__.get(mimeType);\n\n  if (_.isString(klass)) {\n    klass = _.find(processors, function (fn) {\n      return (fn.name && fn.name === 'Processor:' + klass);\n    });\n  }\n\n  this.__preProcessors__.set(mimeType, _.without(processors, klass));\n};\n\n\n/**\n *  Processing#unregisterPostProcessor(mimeType, klass) -> Void\n *\n *  Remove Postprocessor `klass` for `mime_type`.\n *\n *      unregisterPostprocessor('text/css', DirectiveProcessor);\n **/\nmodule.exports.unregisterPostProcessor = function (mimeType, klass) {\n  var processors = this.__postProcessors__.get(mimeType);\n\n  if (_.isString(klass)) {\n    klass = _.find(processors, function (fn) {\n      return (fn.name && fn.name === 'Processor:' + klass);\n    });\n  }\n\n  this.__postProcessors__.set(mimeType, _.without(processors, klass));\n};\n\n\n/**\n *  Processing#unregisterBundleProcessor(mimeType, klass) -> Void\n *\n *  Remove BundleProcessor `klass` for `mime_type`.\n *\n *      unregisterBundleProcessor('text/css', CharsetNormalizer);\n **/\nmodule.exports.unregisterBundleProcessor = function (mimeType, klass) {\n  var processors = this.__bundleProcessors__.get(mimeType);\n\n  if (_.isString(klass)) {\n    klass = _.find(processors, function (fn) {\n      return (fn.name === 'Processor:' + klass);\n    });\n  }\n\n  this.__bundleProcessors__.set(mimeType, _.without(processors, klass));\n};\n\n\n/** internal\n *  Processing#addEngineToTrail(ext, klass) -> Void\n *\n *  Registers extension (and corresponding aliases) for given `klass` in\n *  the `trail`.\n **/\nmodule.exports.addEngineToTrail = function (ext, klass) {\n  var format_ext;\n\n  this.__trail__.appendExtensions(ext);\n\n  if (klass.defaultMimeType) {\n    format_ext = this.getExtensionForMimeType(klass.defaultMimeType);\n    if (format_ext) {\n      this.__trail__.aliasExtension(format_ext, ext);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/processor.js":"/** internal\n *  class Processor\n *\n *  Used to create custom processors without need to extend [[Template]] by\n *  simply providing a function to the processor registration methods:\n *\n *      var name = 'my-pre-processor';\n *      var func = function (context, data, callback) {\n *        callback(null, data.toLowerCase());\n *      };\n *\n *      // register custom pre-processor\n *      environment.registerPreProcessor('text/css', name, func);\n *\n *      // unregister custom pre-processor\n *      environment.unregisterPreProcessor('text/css', name);\n *\n *\n *  ##### See Also:\n *\n *  - [[Context]]\n *  - [[Processing]]\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Template]]\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar inherits = require('util').inherits;\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n// internal\nvar Template = require('./template');\nvar prop     = require('./common').prop;\n\n\n// Class constructor\nvar Processor = module.exports = function Processor() {\n  Template.apply(this, arguments);\n};\n\n\ninherits(Processor, Template);\n\n\n\n// Run processor\nProcessor.prototype.evaluate = function (context) {\n  if (Processor === this.constructor) {\n    throw new Error('Processor can\\'t be used directly. Use `Processor.create()`.');\n  }\n\n  return this.constructor.__func__(context, this.data);\n};\n\n\n/**\n *  Processor.create(name, func) -> Function\n *\n *  Returns new `Processor` subclass.\n **/\nProcessor.create = function (name, func) {\n  var Klass;\n\n  if (!_.isFunction(func)) {\n    throw new Error('Processor#create() expects second argument to be a function.');\n  }\n\n  Klass = function () { Processor.apply(this, arguments); };\n  inherits(Klass, Processor);\n\n  prop(Klass, '__name__', 'Processor(' + name + ')');\n  prop(Klass, '__func__', func);\n\n  return Klass;\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/helpers/compressing.js":"/** internal\n *  mixin Compressing\n *\n *  An internal mixin whose public methods are exposed on the [[Environment]]\n *  and [[Index]] classes.\n **/\n\n\n// REQUIRED PROPERTIES /////////////////////////////////////////////////////////\n//\n// - `__compressors__` (Hash)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n'use strict';\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  Compressing#getCompressors() -> Object\n *\n *  Returns compressors groupped by mime-type.\n **/\nmodule.exports.getCompressors = function () {\n  return this.__compressors__.clone();\n};\n\n\n/**\n *  Compressing#registerCompressor(mimeType, name, klass) -> Void\n *\n *  Registers a compressor `klass` as `name` for `mimeType`.\n *\n *      environment.registerCompressor('text/css', 'sass', SassCompressor);\n **/\nmodule.exports.registerCompressor = function (mimeType, name, klass) {\n  this.__compressors__.get(mimeType)[name] = klass;\n};\n\n\n\n/**\n *  Compressing#cssCompressor -> Template\n *\n *  CSS compression function.\n *\n *  This is a magical property, when you assign your function, it automagically\n *  creates an instance of [[Processor]] with provided function as internal\n *  worker. The function you provide expected to have follwoing signature:\n *\n *      env.cssCompressor = function (context, data) {\n *        var compressed_data;\n *        // ... do something with data...\n *        return compressed_data;\n *      };\n *\n *  Also you can use predifined CSS compressor [CssoCompressor] by passing it's\n *  identifier as a string:\n *\n *      env.cssCompressor = 'csso';\n *\n *  Throws Error if compressor is not a function or not registered one.\n **/\nObject.defineProperty(module.exports, 'cssCompressor', {\n  // Return JS compressor or nil if none is set\n  get: function () {\n    return this.__cssCompressor__ || null;\n  },\n\n  // Assign a compressor to run on `text/css` assets.\n  set: function (compressor) {\n    var mime = 'text/css';\n\n    if (this.__cssCompressor__) {\n      this.unregisterBundleProcessor(mime, this.__cssCompressor__);\n    }\n\n    if (_.isFunction(compressor)) {\n      this.__cssCompressor__ = compressor;\n      this.registerBundleProcessor(mime, 'css_compressor', compressor);\n      return;\n    }\n\n    if (this.__compressors__.get(mime)[compressor]) {\n      this.__cssCompressor__ = this.__compressors__.get(mime)[compressor];\n      this.registerBundleProcessor(mime, this.__cssCompressor__);\n      return;\n    }\n\n    throw new Error('Unknown compressor: ' + compressor);\n  }\n});\n\n\n/**\n *  Compressing#jsCompressor -> Template\n *\n *  JavaScript compression function.\n *\n *  This is a magical property, when you assign your function, it automagically\n *  creates an instance of [[Processor]] with provided function as internal\n *  worker. The function you provide expected to have follwoing signature:\n *\n *      env.jsCompressor = function (context, data) {\n *        var compressed_data;\n *        // ... do something with data...\n *        return compressed_data;\n *      };\n *\n *  Also you can use predifined JS compressor [UglifyCompressor] by passing it's\n *  identifier as a string:\n *\n *      env.jsCompressor = 'uglify';\n *\n *  Throws Error if compressor is not a function or not registered one.\n **/\nObject.defineProperty(module.exports, 'jsCompressor', {\n  // Return JS compressor or nil if none is set\n  get: function () {\n    return this.__jsCompressor__ || null;\n  },\n\n  // Assign a compressor to run on `application/javascript` assets.\n  set: function (compressor) {\n    var mime = 'application/javascript';\n\n    if (this.__jsCompressor__) {\n      this.unregisterBundleProcessor(mime, this.__jsCompressor__);\n    }\n\n    if (_.isFunction(compressor)) {\n      this.__jsCompressor__ = compressor;\n      this.registerBundleProcessor(mime, 'js_compressor', compressor);\n      return;\n    }\n\n    if (this.__compressors__.get(mime)[compressor]) {\n      this.__jsCompressor__ = this.__compressors__.get(mime)[compressor];\n      this.registerBundleProcessor(mime, this.__jsCompressor__);\n      return;\n    }\n\n    throw new Error('Unknown compressor: ' + compressor);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/helpers/configuring.js":"/** internal\n *  mixin Configuring\n *\n *  An internal mixin whose public methods are exposed on the [[Environment]]\n *  and [[Index]] classes.\n **/\n\n\n// REQUIRED PROPERTIES /////////////////////////////////////////////////////////\n//\n// - `__configurations__` (Hash)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n'use strict';\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  Configuring#getConfigurations() -> Object\n *\n *  Returns copy of registered configurations.\n **/\nmodule.exports.getConfigurations = function () {\n  return _.cloneDeep(this.__configurations__);\n};\n\n\n/**\n *  Configuring#registerConfiguration(name, options) -> Void\n *\n *  ##### Example\n *\n *      Mincer.registerConfiguration('autoprefixer', {\n *        enable: function (self) {\n *          self.registerPostProcessor('text/css', Mincer.Autoprefixer);\n *        },\n *        disable: function (self) {\n *          self.unregisterPostProcessor('text/css', Mincer.Autoprefixer);\n *        }\n *      });\n **/\nmodule.exports.registerConfiguration = function (name, options) {\n  options = _.assign({ state: 'disabled' }, options);\n  this.__configurations__[name] = options;\n};\n\n\n// unified access to a config hash by name\nfunction configuration(self, name) {\n  if (!self.__configurations__[name]) {\n    throw new Error('Unknown configuration: ' + name);\n  }\n\n  return self.__configurations__[name];\n}\n\n\n/**\n *  Configuring#isEnabled(name) -> Void\n *\n *  Tells whenever given configuration enabled or not.\n *\n *  ##### Example\n *\n *      if (env.isEnabled('source_maps')) {\n *        // ...\n *      }\n **/\nmodule.exports.isEnabled = function (name) {\n  return configuration(this, name).state === 'enabled';\n};\n\n\n/**\n *  Configuring#enable(name) -> Void\n *\n *  Enable configuration.\n *\n *  ##### Example\n *\n *      env.enable('autoprefixer');\n **/\nmodule.exports.enable = function (name) {\n  var config = configuration(this, name);\n\n  if (config.enable) {\n    config.enable(this);\n  }\n\n  config.state = 'enabled';\n};\n\n\n/**\n *  Configuring#disable(name) -> Void\n *\n *  Disable configuration.\n *\n *  ##### Example\n *\n *      env.disable('autoprefixer');\n **/\nmodule.exports.disable = function (name) {\n  var config = configuration(this, name);\n\n  if (config.disable) {\n    config.disable(this);\n  }\n\n  config.state = 'disabled';\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/helpers/engines.js":"/** internal\n *  mixin Engines\n *\n *  An internal mixin whose public methods are exposed on the [[Environment]]\n *  and [[Index]] classes.\n *\n *  An engine is a type of processor that is bound to an filename\n *  extension. `application.js.coffee` indicates that the\n *  [[CoffeeEngine]] engine will be ran on the file.\n *\n *  Extensions can be stacked and will be evaulated from right to\n *  left. `application.js.coffee.ejs` will first run `EjsEngine`\n *  then [[CoffeeEngine]].\n *\n *  All `Engine`s must follow the [[Template]] interface. It is\n *  recommended to subclass [[Template]].\n *\n *  Its recommended that you register engine changes on your local\n *  `Environment` instance.\n *\n *      environment.registerEngine('.foo', FooProcessor);\n *\n *  The global registry is exposed for plugins to register themselves.\n *\n *      Mincer.registerEngine('.ejs', EjsEngine);\n **/\n\n\n// REQUIRED PROPERTIES /////////////////////////////////////////////////////////\n//\n// - `__engines__` (Object)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n'use strict';\n\n\n// stdlib\nvar path = require('path');\n\n\n// 3rd-party\nvar _ = require('lodash');\n\n\n// internal\nvar getter = require('../common').getter;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n// Normalize extension with a leading `.`.\n//\n//  js          -> .js\n//  foo.js      -> .js\n//  foo/bar.js  -> .js\nfunction normalizeExtension(extension) {\n  return path.extname('foobar.' + path.basename(extension));\n}\n\n\n/**\n *  Engines#getEngines(ext) -> Object|Function\n *\n *  Returns an `Object` map of `extension => Engine`s registered on the\n *  `Environment`. If an `ext` argument is supplied, the `Engine` register\n *  under that extension will be returned.\n *\n *      environment.getEngines()\n *      // -> { \".styl\": StylusEngine, ... }\n *\n *      environment.getEngines('.styl')\n *      // -> StylusEngine\n **/\nmodule.exports.getEngines = function (ext) {\n  if (ext) {\n    return this.__engines__[normalizeExtension(ext)];\n  }\n  return _.clone(this.__engines__);\n};\n\n\n/**\n *  Engines#engineExtensions -> Array\n *\n *  Returns an `Array` of engine extension `String`s.\n *\n *      environment.engineExtensions;\n *      // -> ['.coffee', '.sass', ...]\n **/\ngetter(module.exports, 'engineExtensions', function () {\n  return _.keys(this.__engines__);\n});\n\n\n/**\n *  Engines#registerEngine(ext, klass) -> Void\n *\n *  Registers a new Engine `klass` for `ext`. If the `ext` already\n *  has an engine registered, it will be overridden.\n *\n *      environment.registerEngine('.coffee', CoffeeScriptTemplate);\n **/\nmodule.exports.registerEngine = function (ext, klass) {\n  this.__engines__[normalizeExtension(ext)] = klass;\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/context.js":"/** internal\n *  class Context\n *\n *  `Context` provides helper methods to all [[Template]] processors.\n *  They are typically accessed by EJS templates. You can mix in custom\n *  helpers by injecting them into [[Environment#ContextClass]]. Do not\n *  mix them into `Context` directly.\n *\n *      environment.registerHelper('asset_url', function () {\n *        // ...\n *      });\n *\n *      // or in batch-mode\n *      environment.registerHelper({\n *        asset_url: function () {\n *          // ...\n *        },\n *        // ...\n *      });\n *\n *      <%= asset_url('foo.png') %>\n *\n *  The `Context` also collects dependencies declared by assets.\n *  See [[DirectiveProcessor]] for an example of this.\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar fs        = require('fs');\nvar path      = require('path');\nvar inherits  = require('util').inherits;\n\n\n// 3rd-party\nvar _         = require('lodash');\n\n// internal\nvar getter     = require('./common').getter;\nvar prop       = require('./common').prop;\nvar isAbsolute = require('./common').isAbsolute;\nvar sourcemap  = require('source-map');\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new Context(environment, logicalPath, pathname)\n *  - environment (Environment)\n *  - logicalPath (String)\n *  - pathname (String)\n **/\nvar Context = module.exports = function Context(environment, logicalPath, pathname) {\n  prop(this, 'environment',           environment);\n  prop(this, 'pathname',              pathname);\n\n  prop(this, '__logicalPath__',       logicalPath);\n\n  prop(this, '__requiredPaths__',     []);\n  prop(this, '__stubbedAssets__',     []);\n  prop(this, '__dependencyPaths__',   []);\n  prop(this, '__dependencyAssets__',  [ pathname ]);\n};\n\n\n// Hash of helpers available as locals in the renderers.\n// For each helper, a wrapper will be generated to preserve `this` context.\n//\n// See Context.registerHelper()\nprop(Context.prototype, '__helpers__', {});\n\n\n/**\n *  Context#assetPath(pathname, options) -> String\n *\n *  Helper that returns path to asset and that acts like a 'base' method for\n *  other `*Path` helpers.\n *\n *  Exposed to the engines as `asset_path` helper.\n *\n *  By default this method is not implemented, and you must provide it's\n *  implementation that will fit your needs, e.g.:\n *\n *      environment.ContextClass.defineAssetPath(function (pathname, options) {\n *        var asset = this.environment.findAsset(pathname, options);\n *        return '/assets/' + asset.digestPath;\n *      });\n *\n *  Once implemented, you can use `asset_path` helper, e.g.:\n *\n *      #logo { background: url(<%= asset_path('logo.png') %>) }\n **/\nContext.prototype.assetPath = function assetPath() {\n  throw new Error(\n    'Custom asset_path helper is not implemented\\n\\n' +\n    'Extend your environment context with a custom method.\\n\\n' +\n    '  environment.ContextClass.defineAssetPath(function (pathname, options) {\\n' +\n    '    // ... your code here ... \\n' +\n    '  });'\n  );\n};\n\n\n/**\n *  Context#imagePath(pathname) -> String\n *\n *  Wrapper over [[Context#assetPath]] for image assets.\n *  Exposed to the engines as `image_path` helper.\n **/\n\n/**\n *  Context#videoPath(pathname) -> String\n *\n *  Wrapper over [[Context#assetPath]] for video assets.\n *  Exposed to the engines as `video_path` helper.\n **/\n\n/**\n *  Context#audioPath(pathname) -> String\n *\n *  Wrapper over [[Context#assetPath]] for audio assets.\n *  Exposed to the engines as `audio_path` helper.\n **/\n\n/**\n *  Context#fontPath(pathname) -> String\n *\n *  Wrapper over [[Context#assetPath]] for font assets.\n *  Exposed to the engines as `font_path` helper.\n **/\n\n/**\n *  Context#javascriptPath(pathname) -> String\n *\n *  Wrapper over [[Context#assetPath]] for javascript assets.\n *  Exposed to the engines as `javascript_path` helper.\n **/\n\n/**\n *  Context#stylesheetPath(pathname) -> String\n *\n *  Wrapper over [[Context#assetPath]] for stylesheet assets.\n *  Exposed to the engines as `stylesheet_path` helper.\n **/\n\n[ 'image', 'video', 'audio', 'font', 'javascript', 'stylesheet' ].forEach(function (assetType) {\n  Context.prototype[assetType + 'Path'] = function (pathname) {\n    return this.assetPath(pathname, { type: assetType });\n  };\n});\n\n\n/**\n *  Context#rootPath -> String\n *\n *  Returns the environment path that contains the file.\n *\n *  If `app/javascripts` and `app/stylesheets` are in your path, and\n *  current file is `app/javascripts/foo/bar.js`, `root_path` would\n *  return `app/javascripts`.\n **/\ngetter(Context.prototype, 'rootPath', function () {\n  var pathname = this.pathname;\n\n  return _.find(this.environment.paths, function (path) {\n    return pathname.substr(0, path.length) === path;\n  }).substr(this.environment.root.length + 1);\n});\n\n\n\n/**\n * Context#logicalPath -> String\n *\n *  Returns logical path without any file extensions.\n *\n *      'app/javascripts/application.js'\n *      # => 'app/javascripts/application'\n **/\ngetter(Context.prototype, 'logicalPath', function () {\n  var len = this.__logicalPath__.length, ext = path.extname(this.__logicalPath__);\n  return this.__logicalPath__.substr(0, len - ext.length);\n});\n\n\n/**\n *  Context#contentType -> String\n *\n *  Returns content type of file\n *\n *      'application/javascript'\n *      'text/css'\n **/\ngetter(Context.prototype, 'contentType', function () {\n  return this.environment.contentTypeOf(this.pathname);\n});\n\n\n/**\n *  Context#context -> Context\n *\n *  Returns the context itself.\n **/\ngetter(Context.prototype, 'context', function () {\n  return this;\n});\n\n\n/**\n *  Context#relativePath -> String\n *\n *  Returns AssetAttributes#relativePath of current file.\n **/\ngetter(Context.prototype, 'relativePath', function () {\n  return this.environment.attributesFor(this.pathname).relativePath;\n});\n\n\n/**\n *  Context#resolve(pathname[, options = {}[, fn]]) -> String\n *  - pathname (String)\n *  - options (Object)\n *  - fn (Function)\n *\n *  Given a logical path, `resolve` will find and return the fully\n *  expanded path. Relative paths will also be resolved. An optional\n *  `contentType` restriction can be supplied to restrict the\n *  search.\n *\n *      context.resolve('foo.js')\n *      # => '/path/to/app/javascripts/foo.js'\n *\n *      context.resolve('./bar.js')\n *      # => '/path/to/app/javascripts/bar.js'\n *\n *      context.resolve('foo', {contentType: 'application/javascript'})\n *      # => '/path/to/app/javascripts/foo.js'\n *\n *  You may also provide an iterator function `fn`, that wil be passed to\n *  environments [[Base#resolve]] when needed.\n **/\nContext.prototype.resolve = function (pathname, options, fn) {\n  var self = this, attributes, content_type, resolved;\n\n  options = options || {};\n\n  // If the pathname is absolute, check it existence\n  if (isAbsolute(pathname)) {\n    if (fs.existsSync(pathname)) {\n      return pathname;\n    }\n\n    throw new Error('Couldn\\'t find file \\'' + pathname + '\\'');\n  }\n\n  content_type = options.contentType;\n\n  if (content_type) {\n    if (content_type === '~self~') {\n      content_type = self.contentType;\n    }\n\n    attributes = this.environment.attributesFor(pathname);\n    if (attributes.formatExtension && content_type !== attributes.contentType) {\n      throw new Error(pathname + ' is \\'' + attributes.contentType + '\\', ' +\n                      'not \\'' + content_type + '\\'');\n    }\n\n    resolved = this.resolve(pathname, {}, function (candidate) {\n      if (self.contentType === self.environment.contentTypeOf(candidate)) {\n        return candidate;\n      }\n    });\n\n    if (!resolved) {\n      throw new Error('Could not find file \\'' + pathname + '\\'.');\n    }\n\n    return resolved;\n  }\n\n  return this.environment.resolve(pathname, _.assign({\n    basePath: path.dirname(this.pathname)\n  }, options), fn);\n};\n\n\n/**\n *  Context#dependOn(pathname) -> Void\n *\n *  Allows you to state a dependency on a file without including it.\n *\n *  This is used for caching purposes. Any changes made to\n *  the dependency file with invalidate the cache of the\n *  source file.\n **/\nContext.prototype.dependOn = function (pathname) {\n  this.__dependencyPaths__.push(this.resolve(pathname));\n};\n\n\n/**\n *  Context#dependOnAsset(pathname) -> Void\n *\n *  Allows you to state an asset dependency without including it.\n *\n *  This is used for caching purposes. Any changes that would\n *  invalidate the dependency asset will invalidate the source\n *  file. Unlike [[Context#dependOn]], this will include recursively\n *  the target asset's dependencies.\n **/\nContext.prototype.dependOnAsset = function (pathname) {\n  this.__dependencyAssets__.push(this.resolve(pathname));\n};\n\n\n/**\n *  Context#requireAsset(pathname) -> Void\n *\n *  `requireAsset` declares `path` as a dependency of the file. The\n *  dependency will be inserted before the file and will only be\n *  included once.\n *\n *  If EJS processing is enabled, you can use it to dynamically\n *  require assets.\n *\n *      <%= requireAsset(\"#{framework}.js\") %>\n **/\nContext.prototype.requireAsset = function (pathname) {\n  pathname = this.resolve(pathname, { contentType: '~self~' });\n  this.dependOnAsset(pathname);\n  this.__requiredPaths__.push(pathname);\n};\n\n\n/**\n *  Context#stubAsset(pathname) -> Void\n *\n *  `stubAsset` blacklists `pathname` from being included in the bundle.\n *  `pathname` must be an asset which may or may not already be included\n *  in the bundle.\n **/\nContext.prototype.stubAsset = function (pathname) {\n  this.__stubbedAssets__.push(this.resolve(pathname, { contentType: '~self~' }));\n};\n\n\n/**\n *  Context#isAssetRequirable(pathname) -> Boolean\n *\n *  Tests if target path is able to be safely required into the\n *  current concatenation.\n **/\nContext.prototype.isAssetRequirable = function (pathname) {\n  var content_type, stat;\n\n  pathname      = this.resolve(pathname);\n  content_type  = this.environment.contentTypeOf(pathname);\n  stat          = this.environment.stat(pathname);\n\n  return stat && stat.isFile() &&\n         (!this.contentType || this.contentType === content_type);\n};\n\n\n/**\n *  Context#assetDataUri(pathname) -> String\n *\n *  Returns a Base64-encoded `data:` URI with the contents of the\n *  asset at the specified path, and marks that path as a dependency\n *  of the current file.\n *\n *  Use `assetDataUri` from EJS with CSS or JavaScript assets:\n *\n *      #logo { background: url(<%= asset_data_uri('logo.png') %>) }\n *\n *      $('<img>').attr('src', '<%= asset_data_uri('avatar.jpg') %>')\n **/\nContext.prototype.assetDataUri = function (pathname) {\n  var asset, buffer;\n\n  this.dependOn(pathname);\n\n  asset  = this.environment.findAsset(pathname);\n  buffer = asset.buffer || new Buffer(asset.toString());\n\n  return 'data:' + asset.contentType + ';base64,' + buffer.toString('base64');\n};\n\n\n// internal\n// Annotates exception raisen by the engine/processor\nContext.prototype.annotateError = function (err, klass) {\n  var prefix    = String(klass.__name__ || klass.name || ''),\n      location  = String(this.pathname);\n\n  if (this.__LINE__) {\n    location += ':' + this.__LINE__;\n  }\n\n  if (prefix) {\n    prefix = '[' + prefix + '] ';\n  }\n\n  err.message = prefix + err.message + '  (in ' + location + ')';\n  err.type = 'MINCER_PROCESSOR';\n\n  return err;\n};\n\n\n/**\n *  Context#evaluate(pathname, options = {}, callback) -> String\n *  - pathname (String)\n *  - options (Object)\n *\n *  Reads `pathname` and runs processors on the file.\n **/\nContext.prototype.evaluate = function (pathname, options) {\n  var self = this, locals = {}, attributes, processors, data, map;\n\n  options     = options || {};\n  pathname    = this.resolve(pathname);\n  attributes  = this.environment.attributesFor(pathname);\n  processors  = options.processors || attributes.processors;\n\n  data      = options.data || fs.readFileSync(pathname, 'utf8');\n  map       = options.map || '';\n\n\n  _.forEach(this.__helpers__, function (payload, name) {\n    var helper = payload.helper;\n\n    if (typeof helper === 'function' && payload.options.type !== 'stylus') {\n      helper = helper.bind(self);\n    }\n\n    locals[name] = helper;\n  });\n\n\n  _.forEach(processors, function (ProcessorKlass, idx) {\n    var template;\n\n    try {\n      template  = new ProcessorKlass(pathname, data, map, processors[idx + 1]);\n      var res = template.evaluate(self, locals);\n      data = template.data;\n      map  = template.map;\n      // legacy compat, for old third party engines\n      if (res) { data = res; }\n\n    } catch (err) {\n      throw self.annotateError(err, ProcessorKlass);\n    }\n  });\n\n  return { data: data, map: map };\n};\n\n\n\n// internal helper to define registerHelper() method on destination class\nfunction define_helpers_registrator(Klass) {\n  Klass.registerHelper = function (name, helper, options) {\n    // Scenario: registerHelper('foo', foo_helper[, foo_opts]);\n    if (_.isString(name)) {\n      Klass.prototype[name]             = helper;\n      Klass.prototype.__helpers__[name] = {\n        helper:   helper,\n        options:  Object(options)\n      };\n      return;\n    }\n\n    // Scenario: registerHelper({ foo: foo_helper, ... });\n    _.forEach(name, function (helper, name) {\n      Klass.registerHelper(name, helper);\n    });\n  };\n}\n\n\n\n/**\n *  Context.registerHelper(name, func) -> Void\n *  Context.registerHelper(helpers) -> Void\n *  - name (String)\n *  - func (Function)\n *  - helpers (Object)\n *\n *  Register a helper that will be available in the engines that supports\n *  local helpers (e.g. EJS or Stylus). You should avoid registering helpers\n *  directly on `Context` class in favour of [[Environment#ContextClass]]\n *  (see [[Environment#registerHelper]] as well).\n *\n *  ##### Example\n *\n *      Context.registerHelper('foo', foo_helper);\n *      Context.registerHelper('bar', bar_helper);\n *\n *      // equals to\n *\n *      Context.registerHelper({\n *        foo: foo_helper,\n *        bar: bar_helper\n *      });\n **/\ndefine_helpers_registrator(Context);\n\n\n// Register all standard (built-in) helpers\nContext.registerHelper({\n  asset_data_uri:   Context.prototype.assetDataUri,\n  asset_path:       Context.prototype.assetPath,\n  image_path:       Context.prototype.imagePath,\n  video_path:       Context.prototype.videoPath,\n  audio_path:       Context.prototype.audioPath,\n  font_path:        Context.prototype.fontPath,\n  javascript_path:  Context.prototype.javascriptPath,\n  stylesheet_path:  Context.prototype.stylesheetPath\n});\n\n\n/**\n *  Context.defineAssetPath(func) -> Void\n *\n *  Syntax sugar that provides an easy way to set real implementation of\n *  `assetPath` and propose it to helpers.\n *\n *  ##### Example:\n *\n *      Context.defineAssetPath(function (pathname, options) {\n *        var asset = this.environment.findAsset(pathname, options);\n *        return '/assets/' + asset.digestPath;\n *      });\n **/\nContext.defineAssetPath = function (func) {\n  this.prototype.assetPath = func;\n  this.registerHelper('asset_path', func);\n};\n\n\n/** internal\n *  Context#subclass -> Function\n *\n *  Returns new subclass of [[Context]].\n **/\ngetter(Context, 'subclass', function () {\n  function Klass() { Context.apply(this, arguments); }\n\n  // add class inheritance\n  inherits(Klass, Context);\n\n  // re-expose syntax sugar for custom asset_path helper setter\n  Klass.defineAssetPath = Context.defineAssetPath;\n\n  // clone some own-prototype properties\n  prop(Klass.prototype, '__helpers__', _.clone(Context.prototype.__helpers__));\n\n  // Provide helpers registrator\n  define_helpers_registrator(Klass);\n\n  return Klass;\n});\n\n\n// Just a helper, that can be convenient for external engines/processors\n// Return existing sourcemap (obj.map) with clear sourceRoot, or create\n// dummy one from obj.data & obj.file\n//\n// Required for late map init, because some engines do not support mapping.\n//\nContext.prototype.createSourceMapObject = function (obj) {\n  var map;\n\n  if (obj.map) {\n    map = JSON.parse(obj.map);\n    map.sourceRoot = '';\n    return map;\n  }\n\n  var name = path.basename(obj.file);\n  var smg = new sourcemap.SourceMapGenerator({ file: name });\n\n  obj.data.split('\\n').forEach(function (line, idx) {\n    smg.addMapping({\n      source: name,\n      original: { line: idx + 1, column: 0 },\n      generated: { line: idx + 1, column: 0 }\n    });\n  });\n  smg.setSourceContent(name, obj.data);\n\n  map = smg.toJSON();\n  map.sourceRoot = '';\n\n  return map;\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/index.js":"/** internal\n *  class Index\n *\n *  `Index` is a special cached version of [[Environment]].\n *\n *  The expection is that all of its file system methods are cached\n *  for the instances lifetime. This makes `Index` much faster. This\n *  behavior is ideal in production environments where the file system\n *  is immutable.\n *\n *  `Index` should not be initialized directly. Instead use\n *  [[Environment#index]].\n *\n *\n *  ##### SUBCLASS OF\n *\n *  [[Base]]\n **/\n\n\n'use strict';\n\n\n// internal\nvar Base            = require('./base');\nvar prop            = require('./common').prop;\nvar getter          = require('./common').getter;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/*:nodoc:*\n *  new Index(environment)\n **/\nvar Index = module.exports = function Index(environment) {\n  Base.call(this);\n\n  // some protected properties\n  prop(this, 'environment',           environment);\n  prop(this, 'ContextClass',          environment.ContextClass);\n  prop(this, 'sourceRoot',            environment.sourceRoot);\n\n  // some private properties\n  prop(this, '__trail__',             environment.__trail__.cached);\n  prop(this, '__cache__',             environment.__cache__);\n  prop(this, '__engines__',           environment.getEngines());\n  prop(this, '__mimeTypes__',         environment.registeredMimeTypes);\n  prop(this, '__preProcessors__',     environment.getPreProcessors());\n  prop(this, '__postProcessors__',    environment.getPostProcessors());\n  prop(this, '__bundleProcessors__',  environment.getBundleProcessors());\n  prop(this, '__compressors__',       environment.getCompressors());\n  prop(this, '__configurations__',    environment.getConfigurations());\n  prop(this, '__jsCompressor__',      environment.__jsCompressor__);\n  prop(this, '__cssCompressor__',     environment.__cssCompressor__);\n\n  // make some internal values immutable\n  prop(this, '__digestAlgorithm__',   environment.digestAlgorithm);\n  prop(this, '__version__',           environment.version);\n\n  // internal cache\n  prop(this, '__assets__',            {}, { writable:  true });\n  prop(this, '__digests__',           {}, { writable:  true });\n};\n\n\nrequire('util').inherits(Index, Base);\n\n\n/**\n *  Index#index -> Index\n *\n *  Self-reference to provide same interface as in [[Environment]].\n **/\ngetter(Index.prototype, 'index', function () {\n  return this;\n});\n\n\n/**\n *  Index.getFileDigest(pathname) -> crypto.Hash\n *\n *  Cached version of [[Base#getFileDigest]].\n **/\nIndex.prototype.getFileDigest = function (pathname) {\n  if (typeof this.__digests__[pathname] === 'undefined') {\n    this.__digests__[pathname] = Base.prototype.getFileDigest.call(this, pathname);\n  }\n\n  return this.__digests__[pathname];\n};\n\n\nvar _findAsset = Base.prototype.findAsset;\n\n\n/**\n *  Index#findAsset(pathname[, options]) -> Asset\n *\n *  Caches calls to [[Base#findAsset]].\n *  Pushes cache to the upstream environment as well.\n **/\nIndex.prototype.findAsset = function (pathname, options) {\n  var asset, logical_cache_key, fullpath_cache_key;\n\n  options           = options || {};\n  options.bundle    = (typeof options.bundle === 'undefined') ? true : options.bundle;\n  logical_cache_key = this.cacheKeyFor(pathname, options);\n\n  if (this.__assets__[logical_cache_key]) {\n    return this.__assets__[logical_cache_key];\n  }\n\n  asset = _findAsset.call(this, pathname, options);\n\n  if (asset) {\n    fullpath_cache_key = this.cacheKeyFor(asset.pathname, options);\n\n    // Cache on Index\n    this.__assets__[logical_cache_key]  =\n    this.__assets__[fullpath_cache_key] = asset;\n\n    // Push cache upstream to Environment\n    this.environment.__assets__[logical_cache_key]  =\n    this.environment.__assets__[fullpath_cache_key] = asset;\n\n    return asset;\n  }\n};\n\n\nvar _buildAsset = Base.prototype.buildAsset;\n\n\n// See Base#buildAsset\nIndex.prototype.buildAsset = function (logicalPath, pathname, options) {\n  var self = this, key = this.cacheKeyFor(pathname, options);\n\n  if (!this.__assets__[key]) {\n    this.__assets__[key] = this.cacheAsset(key, function () {\n      return _buildAsset.call(self, logicalPath, pathname, options);\n    });\n  }\n\n  return this.__assets__[key];\n};\n\n\n/** internal\n *  Index#expireIndex() -> Void\n *\n *  Throws an error. Kept for keeping same interface as in [[Environment]].\n **/\nIndex.prototype.expireIndex = function () {\n  throw new Error('Can not modify immutable index');\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/manifest.js":"/**\n *  class Manifest\n *\n *  The Manifest logs the contents of assets compiled to a single\n *  directory. It records basic attributes about the asset for fast\n *  lookup without having to compile. A pointer from each logical path\n *  indicates with fingerprinted asset is the current one.\n *\n *  The JSON is part of the public API and should be considered\n *  stable. This should make it easy to read from other programming\n *  languages and processes that don't have sprockets loaded. See\n *  `#assets` and `#files` for more infomation about the structure.\n **/\n\n\n'use strict';\n\n\n// stdlib\nvar fs     = require('fs');\nvar path   = require('path');\nvar format = require('util').format;\n\n\n// 3rd-party\nvar _         = require('lodash');\nvar pako      = require('pako');\nvar mkdirp    = require('mkdirp').sync;\n\n\n// internal\nvar prop        = require('./common').prop;\nvar getter      = require('./common').getter;\nvar isAbsolute  = require('./common').isAbsolute;\nvar start_timer = require('./common').timer;\nvar logger      = require('./logger');\n\n\n/**\n *  new Manifest(environment, path)\n *\n *  Create new Manifest associated with an `environment`. `path` is\n *  a full path to the manifest json file. The file may or may not\n *  already exist. The dirname of the `path` will be used to write\n *  compiled assets to. Otherwise, if the path is a directory, the\n *  filename will default to \"manifest.json\" in that directory.\n *\n *      new Manifest(environment, \"./public/assets/manifest.json\");\n **/\nvar Manifest = module.exports = function Manifest(environment, pathname) {\n  var data;\n\n  prop(this, 'environment', environment);\n\n  if (path.extname(pathname) === '') {\n    prop(this, 'dir',   path.resolve(pathname));\n    prop(this, 'path',  path.join(this.dir, 'manifest.json'));\n  } else {\n    prop(this, 'dir',   path.dirname(pathname));\n    prop(this, 'path',  path.resolve(pathname));\n  }\n\n  if (fs.existsSync(this.path)) {\n    try {\n      data = require(this.path);\n    } catch (err) {\n      logger.error(this.path + ' is invalid: ' + err);\n    }\n  }\n\n  prop(this, 'data', (!!data && _.isObject(data)) ? data : {});\n};\n\n\n/**\n *  Manifest#assets -> Object\n *\n *  Returns internal assets mapping. Keys are logical paths which\n *  map to the latest fingerprinted filename.\n *\n *\n *  ##### Synopsis:\n *\n *      Logical path (String): Fingerprint path (String)\n *\n *\n *  ##### Example:\n *\n *      {\n *        \"application.js\" : \"application-2e8e9a7c6b0aafa0c9bdeec90ea30213.js\",\n *        \"jquery.js\"      : \"jquery-ae0908555a245f8266f77df5a8edca2e.js\"\n *      }\n **/\ngetter(Manifest.prototype, 'assets', function () {\n  if (!this.data.assets) {\n    this.data.assets = {};\n  }\n\n  return this.data.assets;\n});\n\n\n/**\n *  Manifest#files -> Object\n *\n *  Returns internal file directory listing. Keys are filenames\n *  which map to an attributes array.\n *\n *\n *  ##### Synopsis:\n *\n *      Fingerprint path (String):\n *        logical_path: Logical path (String)\n *        mtime: ISO8601 mtime (String)\n *        digest: Base64 hex digest (String)\n *\n *\n *  ##### Example:\n *\n *    {\n *      \"application-2e8e9a7c6b0aafa0c9bdeec90ea30213.js\" : {\n *        'logical_path'  : \"application.js\",\n *        'mtime'         : \"2011-12-13T21:47:08-06:00\",\n *        'digest'        : \"2e8e9a7c6b0aafa0c9bdeec90ea30213\"\n *      }\n *    }\n **/\ngetter(Manifest.prototype, 'files', function () {\n  if (!this.data.files) {\n    this.data.files = {};\n  }\n\n  return this.data.files;\n});\n\n\n// Coerce data to buffer\nfunction toBuffer(data) {\n  return Buffer.isBuffer(data) ? data : new Buffer(data);\n}\n\n\n// Write data String/Buffer into filename\nfunction write(filename, mtime, data) {\n  var tempname = filename + '+';\n\n  try {\n    mkdirp(path.dirname(filename));\n    fs.writeFileSync(tempname, toBuffer(data));\n    fs.renameSync(tempname, filename);\n    fs.utimesSync(filename, mtime, mtime);\n  } catch (err) {\n    // Try to remove tmp file on error.\n    // Don't check if exists, just suppress errors\n    try { fs.unlinkSync(tempname); } catch (__) {}\n\n    throw err;\n  }\n}\n\n\n// Compress given String or Buffer\nfunction gzip(data) {\n  /* global Uint8Array */\n  return new Buffer(pako.gzip(new Uint8Array(toBuffer(data))));\n}\n\n\n/**\n *  Manifest#compile(files[, options]) -> Object\n *  - files (Array):\n *  - options (Object):\n *\n *  ##### options:\n *\n *  - `sourceMaps` (false) - set `true` to write sourcemap files\n *  - `embedMappingComments` (false) - set `true` to embed sourcemap url\n *    into created files\n *  - `compress` (false) - set `true` to also create gzipped files\n *  - `noSourceMapProtection` (false) - set `true` to skip adding XSSI protection header\n *\n *  Compile and write asset(s) to directory. The asset is written to a\n *  fingerprinted filename like `app-2e8e9a7c6b0aafa0c9bdeec90ea30213.js`.\n *  An entry is also inserted into the manifest file.\n *\n *  Returns manifest content on success. Throws exception on error.\n *\n *      var data = manifest.compile([\"app.js\"]);\n *\n *      //  data => {\n *      //    files: {\n *      //      \"app.js\" : \"app-2e8e9a7c6b0aafa0c9bdeec90ea30213.js\",\n *      //      ...\n *      //    },\n *      //    assets: {\n *      //      \"app-2e8e9a7c6b0aafa0c9bdeec90ea30213.js\" : {\n *      //        \"logical_path\"  : \"app.js\",\n *      //        \"mtime\"         : \"2011-12-13T21:47:08-06:00\",\n *      //        \"digest\"        : \"2e8e9a7c6b0aafa0c9bdeec90ea30213\"\n *      //      },\n *      //      ...\n *      //    }\n *      //  }\n **/\nManifest.prototype.compile = function (files, options) {\n  var self     = this,\n      paths    = [];\n\n  if (!this.environment) {\n    throw new Error('Manifest requries environment for compilation');\n  }\n\n  options = options || {};\n\n  this.environment.eachLogicalPath(files, function (pathname) {\n    paths.push(pathname);\n  });\n\n  paths = _.union(paths, _.filter(files, isAbsolute));\n\n  paths.forEach(function (logicalPath) {\n    var timer = start_timer(), asset, target;\n\n    asset = self.environment.findAsset(logicalPath, { bundle: true });\n\n    if (!asset) {\n      throw new Error('Can not find asset \\'' + logicalPath + '\\'');\n    }\n\n    logger.debug(format('Compiled %s (%dms)', logicalPath, timer.stop()));\n\n    target = path.join(self.dir, asset.digestPath);\n\n    self.assets[asset.logicalPath]  = asset.digestPath;\n    self.files[asset.digestPath]    = {\n      logical_path:   asset.logicalPath,\n      mtime:          asset.mtime.toISOString(),\n      size:           asset.length,\n      digest:         asset.digest\n    };\n\n    if (fs.existsSync(target)) {\n      logger.debug('Skipping ' + target + ', already exists');\n      self.save();\n      return;\n    }\n\n    var buffer;\n\n    if (options.embedMappingComments && options.sourceMaps && asset.sourceMap) {\n      buffer = new Buffer(asset.source + asset.mappingUrlComment());\n    } else {\n      buffer = asset.buffer;\n    }\n\n    write(target, asset.mtime, buffer);\n\n    if (asset.type === 'bundled' && options.compress) {\n      write(target + '.gz', asset.mtime, gzip(buffer));\n    }\n\n    if (asset.sourceMap) {\n      // XSSI protection header enabled by default\n      var header = ')]}\\'\\n';\n\n      // Optionally skip XSSI protection header\n      if (options.noSourceMapProtection) {\n        header = '';\n      }\n\n      write(target + '.map', asset.mtime, header + asset.sourceMap);\n      if (options.compress) {\n        write(target + '.map.gz', asset.mtime, gzip(header + asset.sourceMap));\n      }\n    }\n\n    self.save();\n    logger.info('Writing ' + target);\n  });\n\n  return self.data;\n};\n\n\n// Persist manifest back to FS\nManifest.prototype.save = function () {\n  mkdirp(this.dir);\n  fs.writeFileSync(this.path, JSON.stringify(this.data, null, '  '));\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/server.js":"/**\n *  class Server\n *\n *  Easy to use server/middleware ideal for serving assets your assets:\n *\n *  - great for development, as it recompiles canged assets on-fly\n *  - great for production, as it caches results, and it can become as effecient\n *    as `staticCache` middleware (or even better) of `connect` module.\n *\n *\n *  ##### Examples\n *\n *      // development mode\n *      var srv = new Server(env);\n *\n *      // production mode\n *      var srv = new Server(env.index);\n *\n *      // production mode (restrictive)\n *      var files = ['app.js', 'app.css', 'logo.jpg'];\n *      var srv = new Server(env.index, manifest.compile(files));\n *\n *  You can use this server in your connect app (or as `request` listener of\n *  `http` server) like this:\n *\n *      app.use(function (req, res) {\n *        srv.handle(req, res);\n *      });\n *\n *      // there's a shorthand syntax as well:\n *\n *      app.use(mincer.createServer(env));\n **/\n\n'use strict';\n\n\n// stdlib\nvar zlib   = require('zlib');\nvar http   = require('http');\nvar url    = require('url');\nvar format = require('util').format;\n\n\n// 3rd-party\nvar mimoza       = require('mimoza');\nvar compressible = require('compressible');\n\n\n// internal\nvar logger      = require('./logger');\nvar prop        = require('./common').prop;\nvar start_timer = require('./common').timer;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new Server(environment[, manifest])\n *  - environment (Environment|Index)\n *  - manifest (Object): Data returned by [[Manifest#compile]]\n *\n *  If you provide `manifest`, then server will not even try to find files on\n *  FS unless they are specified in the `manifest`.\n **/\nvar Server = module.exports = function Server(environment, manifest) {\n  prop(this, 'environment', environment);\n  prop(this, 'manifest',    manifest);\n};\n\n\n// Retruns fingerprint from the pathname\nvar FINGERPRINT_RE = /-([0-9a-f]{32,40})\\.[^.]+(?:\\.map)?$/i;\nfunction get_fingerprint(pathname) {\n  var m = FINGERPRINT_RE.exec(pathname);\n  return m ? m[1] : null;\n}\n\n\n// Helper to write the code and end response\nfunction end(res, code) {\n  if (code >= 400) {\n    // check res object contains connect/express request and next structure\n    if (res.req && res.req.next) {\n      var error = new Error(http.STATUS_CODES[code]);\n      error.status = code;\n      return res.req.next(error);\n    }\n\n    // write human-friendly error message\n    res.writeHead(code);\n    res.end('[' + code + '] ' + http.STATUS_CODES[code]);\n    return;\n  }\n\n  // just end with no body for 304 responses and such\n  res.writeHead(code);\n  res.end();\n}\n\n\n// Returns Etag value for `asset`\nfunction etag(asset) {\n  return '\"' + asset.digest + '\"';\n}\n\n\n// Returns true whenever If-None-Match header matches etag of `asset`\nfunction is_etag_match(req, asset) {\n  return etag(asset) === req.headers['if-none-match'];\n}\n\n\n// Tells whenever browser accepts gzip at all\nfunction is_gzip_accepted(req) {\n  var accept = req.headers['accept-encoding'] || '';\n  return accept === '*' || accept.indexOf('gzip') >= 0;\n}\n\n\n// Returns log event structure.\n//\nfunction log_event(req, code, message, elapsed) {\n  return {\n    code:           code,\n    message:        message,\n    elapsed:        elapsed,\n    request:        req,\n    url:            req.originalUrl || req.url,\n    method:         req.method,\n    headers:        req.headers,\n    httpVersion:    req.httpVersion,\n    remoteAddress:  req.connection.remoteAddress\n  };\n}\n\n\nfunction serve_asset(self, asset, req, res, timer) {\n  var buffer, length;\n\n  // OK\n  self.log('info', log_event(req, 200, 'OK', timer.stop()));\n\n  buffer = asset.__server_buffer__;\n  length = asset.__server_buffer__.length;\n\n  //\n  // Alter some headers for gzipped assets\n  //\n\n  //\n  // Only gzip is supported:\n  //\n  // - too many issues with deflate\n  // - browsers that support deflate well, also support gzip\n  //\n  // Details:\n  //\n  // - http://www.vervestudios.co/projects/compression-tests/results\n  // - http://zoompf.com/blog/2012/02/lose-the-wait-http-compression\n  //\n\n  if (asset.__server_buffer_gzipped__ && is_gzip_accepted(req)) {\n    buffer = asset.__server_buffer_gzipped__;\n    length = asset.__server_buffer_gzipped__.length;\n    res.setHeader('Content-Encoding', 'gzip');\n  }\n\n  //\n  // Set content type and length headers\n  // Force charset for text assets, to avoid problems with JS loaders\n  //\n  res.setHeader('Content-Type', asset.contentType + (mimoza.isText(asset.contentType) ? '; charset=UTF-8' : ''));\n  res.setHeader('Content-Length', length);\n\n  res.statusCode = 200;\n\n  if (req.method === 'HEAD') {\n    res.end();\n    return;\n  }\n\n  res.end(buffer);\n}\n\n\nfunction serve_source_map(self, asset, req, res, timer) {\n  var length, buffer;\n\n  if (!asset.__server_sourcemap_buffer__) {\n    self.log('info', log_event(req, 404, 'Not Found', timer.stop()));\n\n    res.statusCode = 404;\n  } else {\n    self.log('info', log_event(req, 200, 'OK', timer.stop()));\n\n    res.statusCode = 200;\n\n    buffer = asset.__server_sourcemap_buffer__;\n    length = asset.__server_sourcemap_buffer__.length;\n\n    if (asset.__gzipped_server_sourcemap__ && is_gzip_accepted(req)) {\n      buffer = asset.__gzipped_server_sourcemap__;\n      length = asset.__gzipped_server_sourcemap__.length;\n      res.setHeader('Content-Encoding', 'gzip');\n    }\n\n    res.setHeader('Content-Type',  'application/json; charset=UTF-8');\n    res.setHeader('Content-Length', length);\n  }\n\n  if (req.method === 'HEAD') {\n    res.end();\n    return;\n  }\n\n  res.end(buffer);\n}\n\n\n/** internal\n *  Server#log(level, event) -> Void\n *  - level (String): Event level\n *  - event (Object): Event data\n *\n *  This is an internal method that formats and writes messages using\n *  [[Mincer.logger]] and it fits almost 99% of cases. But if you want to\n *  integrate this [[Server]] into your existing application and have logs\n *  formatted in your way you can override this method.\n *\n *\n *  ##### Event\n *\n *  Event is an object with following fields:\n *\n *  - **code** (Number): Status code\n *  - **message** (String): Message\n *  - **elapsed** (Number): Time elapsed in milliseconds\n *  - **url** (String): Request url. See `http.request.url`.\n *  - **method** (String): Request method. See `http.request.method`.\n *  - **headers** (Object): Request headers. See `http.request.headers`.\n *  - **httpVersion** (String): Request httpVersion. See `http.request.httpVersion`.\n **/\nServer.prototype.log = function log(level, event) {\n  logger[level](format('Served asset %s - %d %s (%dms)',\n                       event.url, event.code, event.message, event.elapsed));\n};\n\n\n/**\n *  Server#compile(pathname, bundle, callback(err, asset)) -> Void\n *  - pathname (String)\n *  - bundle (Boolean)\n *  - callback (Function)\n *\n *  Finds and compiles given asset.\n **/\nServer.prototype.compile = function compile(pathname, bundle, callback) {\n  var asset;\n\n  try {\n    asset = (this.manifest && !this.manifest.assets[pathname]) ? null\n          : this.environment.findAsset(pathname, { bundle: !!bundle });\n  } catch (err) {\n    callback(err);\n    return;\n  }\n\n  if (!asset) {\n    callback(/* err = undefined, asset = undefined */);\n    return;\n  }\n\n  // return immediately if asset was previously processed\n  if (asset.__server_buffer__) {\n    callback(null, asset);\n    return;\n  }\n\n  // For bundled assets create patched content with embedded url.\n  if (asset.sourceMap && asset.mappingUrlComment) {\n    prop(asset, '__server_buffer__', new Buffer(asset.source + asset.mappingUrlComment()));\n  } else {\n    prop(asset, '__server_buffer__', asset.buffer);\n  }\n\n  if (asset.sourceMap) {\n    prop(asset, '__server_sourcemap_buffer__', new Buffer(')]}\\'\\n' + asset.sourceMap));\n    // Strange \")]}'\\n\" line added to sourcemap is for XSSI protection.\n    // See spec for details.\n  }\n\n  if (!compressible(asset.contentType)) {\n    callback(null, asset);\n    return;\n  }\n\n  // Gzip and cache buffer\n  zlib.gzip(asset.__server_buffer__, function (err, buffer) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    // set __server_buffer_gzipped__ buffer only if we have compression profit\n    if (buffer.length < asset.__server_buffer__.length) {\n      prop(asset, '__server_buffer_gzipped__', buffer);\n    }\n\n    if (!asset.__server_sourcemap_buffer__) {\n      callback(null, asset);\n      return;\n    }\n\n    zlib.gzip(asset.__server_sourcemap_buffer__, function (err, buffer) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      // set __server_buffer_gzipped__ buffer only if we have compression profit\n      if (buffer.length < asset.__server_sourcemap_buffer__.length) {\n        prop(asset, '__gzipped_server_sourcemap__', buffer);\n      }\n\n      callback(null, asset);\n    });\n  });\n};\n\n\n/**\n *  Server#handle(req, res) -> Void\n *  - req (http.ServerRequest)\n *  - res (hhtp.ServerResponse)\n *\n *  Hander function suitable for usage as server `request` event listener or as\n *  middleware for TJ's `connect` module.\n *\n *\n *  ##### Exampple\n *\n *  var assetsSet\n **/\nServer.prototype.handle = function handle(req, res) {\n  var self        = this,\n      timer       = start_timer(),\n      pathname    = url.parse(req.url).pathname,\n      bundle      = !/body=[1t]/.test(url.parse(req.url).query),\n      sourceMap   = /\\.map$/i.test(pathname),\n      fingerprint = get_fingerprint(pathname);\n\n  try {\n    pathname = decodeURIComponent(pathname.replace(/^\\//, ''));\n  } catch (err) {\n    self.log('error', log_event(req, 400, 'Failed decode URL', timer.stop()));\n    end(res, 400);\n    return;\n  }\n\n  // forbid requests with `..` or NUL chars\n  if (pathname.indexOf('..') >= 0 || pathname.indexOf('\\u0000') >= 0) {\n    self.log('error', log_event(req, 403, 'URL contains unsafe chars', timer.stop()));\n    end(res, 403);\n    return;\n  }\n\n  // ignore non-GET requests\n  if (req.method !== 'GET' && req.method !== 'HEAD') {\n    self.log('error', log_event(req, 403, 'HTTP method not allowed', timer.stop()));\n    end(res, 403);\n    return;\n  }\n\n  // remove fingerprint (digest) from URL\n  if (fingerprint) {\n    pathname = pathname.replace('-' + fingerprint, '');\n  }\n\n  // remove .map extension from pathname\n  if (sourceMap) {\n    pathname = pathname.replace(/\\.map$/i, '');\n  }\n\n  // try to find and compile asset\n  this.compile(pathname, bundle, function (err, asset) {\n    if (err) {\n      err = err.message || err.toString();\n      self.log('error', log_event(req, 500, 'Error compiling asset: ' + err, timer.stop()));\n      end(res, 500);\n      return;\n    }\n\n    // asset not found\n    if (!asset) {\n      self.log('error', log_event(req, 404, 'Not found', timer.stop()));\n      end(res, 404);\n      return;\n    }\n\n    //\n    // Asset found. Sending headers for 200/304 responses:\n    // http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-18#section-4.1\n    //\n\n    //\n    // Ranges are not supported yet\n    //\n\n    res.removeHeader('Accept-Ranges');\n\n    //\n    // Mark for proxies, that we can return different content (plain & gzipped),\n    // depending on specified (comma-separated) headers\n    //\n\n    res.setHeader('Vary', 'Accept-Encoding');\n\n    //\n    // Set caching headers\n    //\n\n    if (fingerprint) {\n      // If the request url contains a fingerprint, set a long\n      // expires on the response\n      res.setHeader('Cache-Control', 'public, max-age=31536000');\n    } else {\n      // Otherwise set `must-revalidate` since the asset could be modified.\n      res.setHeader('Cache-Control', 'public, max-age=0, must-revalidate');\n    }\n\n    res.setHeader('Date',           (new Date()).toUTCString());\n    res.setHeader('Last-Modified',  asset.mtime.toUTCString());\n    res.setHeader('ETag',           etag(asset));\n    res.setHeader('Server',         'Nokla 1630');\n\n    //\n    // Check if asset's etag matches `if-none-match` header\n    //\n\n    if (is_etag_match(req, asset)) {\n      self.log('info', log_event(req, 304, 'Not Modified', timer.stop()));\n      end(res, 304);\n      return;\n    }\n\n    if (sourceMap) {\n      serve_source_map(self, asset, req, res, timer);\n    } else {\n      serve_asset(self, asset, req, res, timer);\n    }\n  });\n};\n\n\n/**\n *  Server.createServer(environment[, manifest]) -> Function\n *  - environment (Environment)\n *  - manifest (Object)\n *\n *  Returns a server function suitable to be used as `request` event handler of\n *  `http` Node library module or as `connect` middleware.\n *\n *\n *  ##### Example\n *\n *      // Using TJ's Connect module\n *      var app = connect();\n *      app.use('/assets/', Server.createServer(env));\n *\n *\n *  ##### See Also\n *\n *  - [[Server.new]]\n **/\nServer.createServer = function (environment, manifest) {\n  var srv = new Server(environment, manifest);\n  return function (req, res) {\n    return srv.handle(req, res);\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-mincer/node_modules/mincer/lib/mincer/file_store.js":"/**\n *  class FileStore\n *\n *  Cache backend that keeps assets cache on FS.\n *\n *  ##### Usage\n *\n *      env.cache = new FileStore('/path/to/cache');\n **/\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n'use strict';\n\n\n// stdlib\nvar fs      = require('fs');\nvar exists  = fs.existsSync;\nvar read    = fs.readFileSync;\nvar write   = fs.writeFileSync;\nvar path    = require('path');\n\n\n// 3rd-party\nvar mkdirp  = require('mkdirp').sync;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n\n/**\n *  new FileStore(root)\n *  - root (String): cache path root\n **/\nvar FileStore = module.exports = function FileStore(root) {\n  this.root = path.resolve(root);\n};\n\n\n\nFileStore.prototype.get = function (key) {\n  var dataFile = path.join(this.root, key),\n      metaFile = path.join(this.root, key + '.json'),\n      hash     = null;\n\n  if (exists(metaFile)) {\n    // using read + toString for backward compatibility\n    hash = JSON.parse(read(metaFile).toString('utf8'));\n    hash.source = read(dataFile).toString('utf8');\n  }\n\n  return hash;\n};\n\n\nFileStore.prototype.set = function (key, hash) {\n  var dataFile = path.join(this.root, key),\n      metaFile = path.join(this.root, key + '.json'),\n      source   = hash.source || '';\n\n  delete hash.source;\n\n  mkdirp(path.dirname(metaFile));\n  write(metaFile, JSON.stringify(hash));\n  write(dataFile, source);\n};\n"}